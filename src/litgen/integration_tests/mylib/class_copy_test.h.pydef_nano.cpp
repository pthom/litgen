// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: class_copy_test.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <nanobind/nanobind.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/function.h>
#include "mylib_main/mylib.h"

namespace py = nanobind;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module_& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:class_copy_test.h>    ////////////////////
    auto pyClassCopyable_ImplicitCopyCtor =
        nb::class_<Copyable_ImplicitCopyCtor>
            (m, "Copyable_ImplicitCopyCtor", "")
        .def("__init__", [](Copyable_ImplicitCopyCtor * self, int a = 1)
        {
            new (self) Copyable_ImplicitCopyCtor();  // placement new
            auto r_ctor_ = self;
            r_ctor_->a = a;
        },
        nb::arg("a") = 1
        )
        .def_rw("a", &Copyable_ImplicitCopyCtor::a, "")
        .def("__copy__",  [](const Copyable_ImplicitCopyCtor &self) {
            return Copyable_ImplicitCopyCtor(self);
        })
        .def("__deepcopy__",  [](const Copyable_ImplicitCopyCtor &self, nb::dict) {
            return Copyable_ImplicitCopyCtor(self);
        }, nb::arg("memo"))    ;


    auto pyClassCopyable_ExplicitCopyCtor =
        nb::class_<Copyable_ExplicitCopyCtor>
            (m, "Copyable_ExplicitCopyCtor", "")
        .def(nb::init<>())
        .def(nb::init<const Copyable_ExplicitCopyCtor &>(),
            nb::arg("other"))
        .def_rw("a", &Copyable_ExplicitCopyCtor::a, "")
        .def("__copy__",  [](const Copyable_ExplicitCopyCtor &self) {
            return Copyable_ExplicitCopyCtor(self);
        })
        .def("__deepcopy__",  [](const Copyable_ExplicitCopyCtor &self, nb::dict) {
            return Copyable_ExplicitCopyCtor(self);
        }, nb::arg("memo"))    ;


    auto pyClassCopyable_ExplicitPrivateCopyCtor =
        nb::class_<Copyable_ExplicitPrivateCopyCtor>
            (m, "Copyable_ExplicitPrivateCopyCtor", "")
        .def(nb::init<>())
        .def_rw("a", &Copyable_ExplicitPrivateCopyCtor::a, "")
        ;


    auto pyClassCopyable_DeletedCopyCtor =
        nb::class_<Copyable_DeletedCopyCtor>
            (m, "Copyable_DeletedCopyCtor", "")
        .def_rw("a", &Copyable_DeletedCopyCtor::a, "")
        .def(nb::init<>())
        ;

    { // <namespace AAA>
        nb::module_ pyNsAAA = m.def_submodule("aaa", "");
        auto pyNsAAA_ClassCopyable_Template_int =
            nb::class_<AAA::Copyable_Template<int>>
                (pyNsAAA, "Copyable_Template_int", "")
            .def("__init__", [](AAA::Copyable_Template<int> * self, int value = int())
            {
                new (self) AAA::Copyable_Template<int>();  // placement new
                auto r_ctor_ = self;
                r_ctor_->value = value;
            },
            nb::arg("value") = int()
            )
            .def_rw("value", &AAA::Copyable_Template<int>::value, "")
            .def("__copy__",  [](const AAA::Copyable_Template<int> &self) {
                return AAA::Copyable_Template<int>(self);
            })
            .def("__deepcopy__",  [](const AAA::Copyable_Template<int> &self, nb::dict) {
                return AAA::Copyable_Template<int>(self);
            }, nb::arg("memo"))    ;
    } // </namespace AAA>
    ////////////////////    </generated_from:class_copy_test.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
