// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: return_value_policy_test.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <nanobind/nanobind.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/function.h>
#include "mylib_main/mylib.h"

namespace py = nanobind;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module_& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:return_value_policy_test.h>    ////////////////////
    auto pyClassMyConfig =
        nb::class_<MyConfig>
            (m, "MyConfig", "")
        .def("__init__", [](MyConfig * self, int value = 0)
        {
            new (self) MyConfig();  // placement new
            auto r_ctor_ = self;
            r_ctor_->value = value;
        },
        nb::arg("value") = 0
        )
        .def_static("instance",
            &MyConfig::Instance,
            "// return_value_policy::reference",
            nb::rv_policy::reference)
        .def_rw("value", &MyConfig::value, "")
        ;


    m.def("my_config_instance",
        MyConfigInstance,
        "return_value_policy::reference",
        nb::rv_policy::reference);
    ////////////////////    </generated_from:return_value_policy_test.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
