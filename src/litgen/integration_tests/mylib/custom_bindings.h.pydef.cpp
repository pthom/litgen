// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: custom_bindings.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>
#include "mylib_main/mylib.h"

namespace py = pybind11;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:custom_bindings.h>    ////////////////////

    { // <namespace RootCustom>
        py::module_ pyNsRootCustom = m.def_submodule("root_custom", "");
        auto pyNsRootCustom_ClassFoo =
            py::class_<RootCustom::Foo>
                (pyNsRootCustom, "Foo", "")
            .def(py::init<>([](
            int mValue = 0)
            {
                auto r_ctor_ = std::make_unique<RootCustom::Foo>();
                r_ctor_->mValue = mValue;
                return r_ctor_;
            })
            , py::arg("m_value") = 0
            )
            .def_readwrite("m_value", &RootCustom::Foo::mValue, "")
            ;

        pyNsRootCustom_ClassFoo.def("get_value", [](const RootCustom::Foo& self){ return self.mValue; });
        pyNsRootCustom_ClassFoo.def("set_value", [](RootCustom::Foo& self, int value){ self.mValue = value; });



        // Example of adding a custom function to the submodule
        pyNsRootCustom.def("foo_namespace_function", []() -> int { return 53; });
    } // </namespace RootCustom>
    ////////////////////    </generated_from:custom_bindings.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
