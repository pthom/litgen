// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: class_virtual_test.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <nanobind/nanobind.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/function.h>
#include "mylib_main/mylib.h"

namespace py = nanobind;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

namespace Root { namespace Inner {
// helper type to enable overriding virtual methods in python
class MyVirtualClass_trampoline : public MyVirtualClass
{
public:
    NB_TRAMPOLINE(MyVirtualClass, 3);

    int foo_virtual_public_pure() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "foo_virtual_public_pure", // function name (python)
            foo_virtual_public_pure // function name (c++)
        );
    }
    int foo_virtual_protected(int x) const override
    {
        NB_OVERRIDE_NAME(
            "foo_virtual_protected", // function name (python)
            foo_virtual_protected, // function name (c++)
            x // params
        );
    }
    std::string foo_virtual_protected_const_const(const std::string & name) const override
    {
        NB_OVERRIDE_NAME(
            "foo_virtual_protected_const_const", // function name (python)
            foo_virtual_protected_const_const, // function name (c++)
            name // params
        );
    }
};
} }  // namespace Inner  // namespace Root

namespace Root { namespace Inner {
// helper type to enable overriding virtual methods in python
class MyVirtualDerivate_trampoline : public MyVirtualDerivate
{
public:
    NB_TRAMPOLINE(MyVirtualDerivate, 4);

    int foo_virtual_public_pure() const override
    {
        NB_OVERRIDE_NAME(
            "foo_virtual_public_pure", // function name (python)
            foo_virtual_public_pure // function name (c++)
        );
    }
    int foo_derivate() override
    {
        NB_OVERRIDE_NAME(
            "foo_derivate", // function name (python)
            foo_derivate // function name (c++)
        );
    }
    int foo_virtual_protected(int x) const override
    {
        NB_OVERRIDE_NAME(
            "foo_virtual_protected", // function name (python)
            foo_virtual_protected, // function name (c++)
            x // params
        );
    }
    std::string foo_virtual_protected_const_const(const std::string & name) const override
    {
        NB_OVERRIDE_NAME(
            "foo_virtual_protected_const_const", // function name (python)
            foo_virtual_protected_const_const, // function name (c++)
            name // params
        );
    }
};
} }  // namespace Inner  // namespace Root

namespace Root { namespace Inner {
// helper type for exposing protected functions
class MyVirtualClass_publicist : public MyVirtualClass
{
public:
    using MyVirtualClass::foo_virtual_protected;
    using MyVirtualClass::foo_virtual_protected_const_const;
};
} }  // namespace Inner  // namespace Root

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module_& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:class_virtual_test.h>    ////////////////////

    { // <namespace Root>
        nb::module_ pyNsRoot = m.def_submodule("root", "");
        { // <namespace Inner>
            nb::module_ pyNsRoot_NsInner = pyNsRoot.def_submodule("inner", "");
            auto pyNsRoot_NsInner_ClassMyVirtualClass =
                nb::class_<Root::Inner::MyVirtualClass, Root::Inner::MyVirtualClass_trampoline>
                    (pyNsRoot_NsInner, "MyVirtualClass", "")
                .def(nb::init<>()) // implicit default constructor
                .def("foo_concrete",
                    &Root::Inner::MyVirtualClass::foo_concrete, nb::arg("x"), nb::arg("name"))
                .def("foo_virtual_public_pure",
                    &Root::Inner::MyVirtualClass::foo_virtual_public_pure)
                .def("foo_virtual_protected",
                    &Root::Inner::MyVirtualClass_publicist::foo_virtual_protected, nb::arg("x"))
                .def("foo_virtual_protected_const_const",
                    &Root::Inner::MyVirtualClass_publicist::foo_virtual_protected_const_const, nb::arg("name"))
                ;


            auto pyNsRoot_NsInner_ClassMyVirtualDerivate =
                nb::class_<Root::Inner::MyVirtualDerivate, Root::Inner::MyVirtualClass, Root::Inner::MyVirtualDerivate_trampoline>
                    (pyNsRoot_NsInner, "MyVirtualDerivate", " Here, we test Combining virtual functions and inheritance\n See https://pybind11.readthedocs.io/en/stable/advanced/classes.html#combining-virtual-functions-and-inheritance")
                .def(nb::init<>())
                .def("foo_virtual_public_pure",
                    &Root::Inner::MyVirtualDerivate::foo_virtual_public_pure)
                .def("foo_derivate",
                    &Root::Inner::MyVirtualDerivate::foo_derivate)
                ;
        } // </namespace Inner>

    } // </namespace Root>
    ////////////////////    </generated_from:class_virtual_test.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
