// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: class_test.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>
#include "mylib/mylib_main/mylib.h"

namespace py = pybind11;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:class_test.h>    ////////////////////
    auto pyClassMyClass =
        py::class_<MyClass>
            (m, "MyClass", "This is the class doc. It will be published as MyClass.__doc__")
        .def(py::init<int, const std::string &>(),
            py::arg("factor") = 10, py::arg("message") = "hello")
        .def_readwrite("factor", &MyClass::factor, "")
        .def_readwrite("delta", &MyClass::delta, "")
        .def_readwrite("message", &MyClass::message, "")
        .def_readwrite("numbers", &MyClass::numbers, " By default, modifications from python are not propagated to C++ for stl containers\n (see https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html)")
        .def("append_number_from_cpp",
            &MyClass::append_number_from_cpp,
            py::arg("v"),
            "However you can call dedicated modifying methods")
        .def_property("values",
            [](MyClass &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<int>::format());
                auto base = pybind11::array(dtype, {2}, {sizeof(int)});
                return pybind11::array(dtype, {2}, {sizeof(int)}, self.values, base);
            }, [](MyClass& self) {},
            "")
        .def_property("flags",
            [](MyClass &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<bool>::format());
                auto base = pybind11::array(dtype, {3}, {sizeof(bool)});
                return pybind11::array(dtype, {3}, {sizeof(bool)}, self.flags, base);
            }, [](MyClass& self) {},
            "")
        .def_readonly_static("const_static_value", &MyClass::const_static_value, "")
        .def_readwrite_static("static_value", &MyClass::static_value, "")
        .def("calc",
            &MyClass::calc,
            py::arg("x"),
            "calc: example of simple method")
        .def("set_message",
            &MyClass::set_message,
            py::arg("m"),
            "set_message: another example of simple method")
        .def_static("static_message",
            &MyClass::static_message, "Returns a static message")
        ;


    auto pyClassMySingletonClass =
        py::class_<MySingletonClass, std::unique_ptr<MySingletonClass, py::nodelete>>
            (m, "MySingletonClass", " MySingletonClass: demonstrate how to instantiate a singleton\n - The instance method shall return with return_value_policy::reference\n - The destructor may be private")
        .def_readwrite("value", &MySingletonClass::value, "")
        .def(py::init<>())
        .def_static("instance",
            &MySingletonClass::instance,
            "py::return_value_policy::reference",
            py::return_value_policy::reference)
        ;


    auto pyClassMyFinalClass =
        py::class_<MyFinalClass>
            (m, "MyFinalClass", py::is_final(), " This struct is final, and thus cannot be inherited from python\n(final class)")
        .def(py::init<>()) // implicit default constructor
        .def("foo",
            &MyFinalClass::foo)
        ;


    auto pyClassMyStructDynamic =
        py::class_<MyStructDynamic>
            (m, "MyStructDynamic", py::dynamic_attr(), " This class accepts dynamic attributes\n see autogenerate_mylib.py:\n     options.class_dynamic_attributes__regex = r\"Dynamic$\"")
        .def(py::init<>([](
        int cpp_member = 1)
        {
            auto r = std::make_unique<MyStructDynamic>();
            r->cpp_member = cpp_member;
            return r;
        })
        , py::arg("cpp_member") = 1
        )
        .def_readwrite("cpp_member", &MyStructDynamic::cpp_member, "")
        ;


    auto pyClassMyStructWithNestedEnum =
        py::class_<MyStructWithNestedEnum>
            (m, "MyStructWithNestedEnum", "");

    { // inner classes & enums of MyStructWithNestedEnum
        auto pyEnumChoice =
            py::enum_<MyStructWithNestedEnum::Choice>(pyClassMyStructWithNestedEnum, "Choice", py::arithmetic(), "")
                .value("a", MyStructWithNestedEnum::Choice::A, "");
    } // end of inner classes & enums of MyStructWithNestedEnum

    pyClassMyStructWithNestedEnum
        .def(py::init<>()) // implicit default constructor
        .def("handle_choice",
            &MyStructWithNestedEnum::HandleChoice,
            py::arg("value") = MyStructWithNestedEnum::Choice::A,
            " The first param of this function uses the inner scope of this class!\n When building the bindings, we need to add MyStructWithNestedEnum::")
        ;
    ////////////////////    </generated_from:class_test.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
