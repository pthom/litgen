// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: operators.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <nanobind/nanobind.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/function.h>
#include "mylib_main/mylib.h"

namespace py = nanobind;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module_& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:operators.h>    ////////////////////
    auto pyClassIntWrapper =
        nb::class_<IntWrapper>
            (m, "IntWrapper", "")
        .def_rw("value", &IntWrapper::value, "")
        .def(nb::init<int>(),
            nb::arg("v"))
        .def("__add__",
            &IntWrapper::operator+, nb::arg("b"))
        .def("__sub__",
            nb::overload_cast<IntWrapper>(&IntWrapper::operator-), nb::arg("b"))
        .def("__neg__",
            [](IntWrapper & self) { return self.operator-(); }, "Unary minus operator")
        .def("__lt__",
            &IntWrapper::operator<,
            nb::arg("b"),
            "Comparison operator")
        .def("__iadd__",
            nb::overload_cast<IntWrapper>(&IntWrapper::operator+=), nb::arg("b"))
        .def("__iadd__",
            nb::overload_cast<int>(&IntWrapper::operator+=), nb::arg("b"))
        .def("__call__",
            nb::overload_cast<IntWrapper>(&IntWrapper::operator()), nb::arg("b"))
        .def("__call__",
            nb::overload_cast<int>(&IntWrapper::operator()), nb::arg("b"))
        ;


    auto pyClassIntWrapperSpaceship =
        nb::class_<IntWrapperSpaceship>
            (m, "IntWrapperSpaceship", "")
        .def_rw("value", &IntWrapperSpaceship::value, "")
        .def(nb::init<int>(),
            nb::arg("v"))
        .def("__lt__",
            [](IntWrapperSpaceship & self, IntWrapperSpaceship & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  < 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__le__",
            [](IntWrapperSpaceship & self, IntWrapperSpaceship & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  <= 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__eq__",
            [](IntWrapperSpaceship & self, IntWrapperSpaceship & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  == 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__ge__",
            [](IntWrapperSpaceship & self, IntWrapperSpaceship & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  >= 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__gt__",
            [](IntWrapperSpaceship & self, IntWrapperSpaceship & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  > 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__lt__",
            [](IntWrapperSpaceship & self, int & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  < 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__le__",
            [](IntWrapperSpaceship & self, int & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  <= 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__eq__",
            [](IntWrapperSpaceship & self, int & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  == 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__ge__",
            [](IntWrapperSpaceship & self, int & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  >= 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        .def("__gt__",
            [](IntWrapperSpaceship & self, int & o) -> bool
            {
                auto cmp = [&self](auto&& other) -> bool {
                    return self.operator<=>(other)  > 0;
                };

                return cmp(o);
            },     nb::arg("o"))
        ;
    ////////////////////    </generated_from:operators.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
