

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>litgen options &#8212; litgen, the Literate Generator</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '02_03_00_options';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Headers processing" href="02_05_00_headers.html" />
    <link rel="prev" title="First steps" href="02_00_00_first_steps.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="00_00_intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/litgen_logo_big.png" class="logo__image only-light" alt="litgen, the Literate Generator - Home"/>
    <script>document.write(`<img src="_static/litgen_logo_big.png" class="logo__image only-dark" alt="litgen, the Literate Generator - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="00_00_intro.html">
                    litgen
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_05_00_install_or_online.html">Installation or online usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_05_05_online.html">Use litgen online</a></li>
<li class="toctree-l1"><a class="reference internal" href="litgen_template/README.html">Quickstart with litgen</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Bindings - Advanced Topics</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="02_00_00_first_steps.html">First steps</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">litgen options</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_05_00_headers.html">Headers processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_05_10_amalgamation.html">Headers amalgamation</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_05_00_code_layout.html">Generated code layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_05_00_names_translation.html">Names and types translation</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_05_00_functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_05_00_classes.html">Classes and structs</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_05_00_templates.html">Template classes and functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_05_00_enums.html">Enums</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_05_00_namespaces.html">Namespaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_05_00_preprocessor.html">Preprocessor and macros</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_05_00_ignore_warnings.html">Ignore litgen warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_05_00_post_processing.html">Postprocessing and preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_05_00_srcml_issues.html">srcML - C++ parsing advices</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Litgen as C++ transformation tool</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="20_00_00_cpp_intro.html">srcmlcpp: C++ code parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="20_05_00_cpp_simple_transformations.html">Simple C++ code transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="20_20_00_install_srcml.html">Optional: install srcML command line tool</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/pthom/litgen/main?urlpath=lab/tree/litgen-book/02_03_00_options.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pthom/litgen" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pthom/litgen/issues/new?title=Issue%20on%20page%20%2F02_03_00_options.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/02_03_00_options.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>litgen options</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#note-about-regexes">Note about regexes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#litgen-main-options">litgen main options</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#srcmlcpp-options">srcmlcpp options</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="litgen-options">
<h1>litgen options<a class="headerlink" href="#litgen-options" title="Permalink to this heading">#</a></h1>
<p>litgen uses numerous options which can be found here: <a class="reference external" href="https://github.com/pthom/litgen/blob/main/src/litgen/options.py">litgen/options.py</a>.</p>
<section id="note-about-regexes">
<h2>Note about regexes<a class="headerlink" href="#note-about-regexes" title="Permalink to this heading">#</a></h2>
<p>Many options use regexes: see the note about their usage in the <a class="reference external" href="https://github.com/pthom/litgen/blob/main/src/litgen/options.py">options.py</a> file:</p>
<p>regexes can support several alternatives: separate them by “|”.</p>
<p>For example, in order to match an exact function name (<code class="docutils literal notranslate"><span class="pre">YourFunctionName</span></code>), as well as functions ending with <code class="docutils literal notranslate"><span class="pre">_private</span></code>, use a regex like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     r&quot;^YourFunctionName$|_private$&quot;,
</pre></div>
</div>
<p><em>Tips:</em></p>
<ul class="simple">
<li><p>If a regex string is empty, it will not match anything (this is specific to litgen)</p></li>
<li><p>To match everything, use r”.*”</p></li>
<li><p>It is advised to prefix your regex strings with “r” (in order to use raw strings)</p></li>
</ul>
</section>
<section id="litgen-main-options">
<h2>litgen main options<a class="headerlink" href="#litgen-main-options" title="Permalink to this heading">#</a></h2>
<p>Below, we show the content of litgen/options.py:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">codemanip</span> <span class="kn">import</span> <span class="n">code_utils</span>
<span class="kn">from</span> <span class="nn">litgen.demo</span> <span class="kn">import</span> <span class="n">litgen_demo</span>

<span class="n">litgen_options_code</span> <span class="o">=</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">download_url_content</span><span class="p">(</span>
    <span class="s2">&quot;https://raw.githubusercontent.com/pthom/litgen/main/src/litgen/options.py&quot;</span>
<span class="p">)</span>
<span class="n">litgen_demo</span><span class="o">.</span><span class="n">show_python_code</span><span class="p">(</span><span class="n">litgen_options_code</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;litgen/options.py&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<style>
.collapsible_header {
  background-color: #AAAAAA;
  color: white;
  cursor: pointer;
  padding: 3px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-style: italic;
}

.collapsible_header_opened {
  background-color: #555;
}

.collapsible_header:hover {
  background-color: #AAAAFF;
}

.collapsible_header:after {
  content: '\002B';
  color: white;
  font-weight: bold;
  float: right;
  margin-left: 5px;
}

.collapsible_header_opened:after {
  content: "\2212";
}

.collapsible_content {
  padding: 0 18px;
  max-height: 0;
  overflow-x: scroll;
  overflow-y: scroll;
  min-width: 100%;
  transition: max-height 0.2s ease-out;
  background-color: #f1f1f1;
}
</style>

    <script>
       function copy_code_1731710856063_79() {
            let code = `from __future__ import annotations

from enum import Enum
from typing import Any, Callable, List

from codemanip import code_utils
from codemanip.code_replacements import RegexReplacementList

from srcmlcpp import SrcmlcppOptions

from litgen.internal.template_options import TemplateFunctionsOptions, TemplateClassOptions
from litgen.internal.class_iterable_info import ClassIterablesInfos


class BindLibraryType(Enum):
    pybind11 = 1
    nanobind = 2


class LitgenOptions:
    """Numerous options to configure litgen code generation.

    (include / excludes, indentation, c++ to python translation settings, function parameters
    adaptations, etc.)"""

    # ------------------------------------------------------------------------------
    # Note about regexes below:
    # =========================
    # - regexes can support several alternatives: separate them by "|"
    # For example, in order to match an exact function name, as well as functions ending with "_private",
    # use a regex like this:
    #         r"^YourFunctionName\$|_private\$",
    # - If a regex string is empty, it will not match anything
    # - To match everything, use r".*"
    # - It is advised to prefix your regex strings with "r" (in order to use raw strings)
    # ------------------------------------------------------------------------------

    ################################################################################
    #    <bind library options>
    ################################################################################
    #
    bind_library: BindLibraryType = BindLibraryType.pybind11

    ################################################################################
    #    <srcmlcpp options>
    ################################################################################
    # There are interesting options to set in SrcmlcppOptions (see srcmlcpp/srcmlcpp_options.py)
    #
    # Notably:
    # * fill srcmlcpp_options.functions_api_prefixes: the prefix(es) that denotes exported dll functions
    # * also set LitgenOptions.fn_exclude_non_api=True if you want to exclude non api functions and methods
    srcmlcpp_options: SrcmlcppOptions

    ################################################################################
    #    <Layout settings for the generated python stub code>
    ################################################################################
    #    <show the original location and or signature of elements as a comment>
    original_location_flag_show = False
    # if showing location, how many parent folders shall be shown
    # (if -1, show the full path)
    original_location_nb_parent_folders = 0
    # If True, the complete C++ original signature will be show as a comment in the python stub (pyi)
    original_signature_flag_show = False
    # Size of an indentation in the python stubs
    python_indent_size = 4
    python_ident_with_tabs: bool = False
    # Insert as many empty lines in the python stub as found in the header file, keep comments layout, etc.
    python_reproduce_cpp_layout: bool = True
    # The generated code will try to adhere to this max length (if negative, this is ignored)
    python_max_line_length = 88
    # Strip (remove) empty comment lines
    python_strip_empty_comment_lines: bool = False
    # Run black formatter
    python_run_black_formatter: bool = False
    python_black_formatter_line_length: int = 88

    ################################################################################
    #    <Layout settings for the C++ generated pydef code>
    ################################################################################
    # Spacing option in C++ code
    cpp_indent_size: int = 4
    cpp_indent_with_tabs: bool = False

    ################################################################################
    #    <Disable comments inclusion in C++ and Python>
    ################################################################################
    comments_exclude: bool = False

    ################################################################################
    #    <names translation from C++ to python>
    ################################################################################
    # Convert variables, functions and namespaces names to snake_case (class, structs, and enums names are always preserved)
    python_convert_to_snake_case: bool = True
    # List of code replacements when going from C++ to Python
    # Notes:
    # - by default, type_replacements is prefilled with standard_type_replacements()
    #   type_replacements will be applied to all types (including class and enum names)
    # - by default, value_replacements is prefilled with standard_value_replacements()
    # - by default, comments_replacements is prefilled with standard_comments_replacements()
    # - by default, the others are empty
    # - type_replacements, var_names_replacements and function_names_replacements enable you
    #   to modify the outputted python code
    type_replacements: RegexReplacementList  # = cpp_to_python.standard_type_replacements() by default
    var_names_replacements: RegexReplacementList  # = RegexReplacementList() by default (i.e. empty)
    namespace_names_replacements: RegexReplacementList  # = RegexReplacementList() by default (i.e. empty)
    function_names_replacements: RegexReplacementList  # = RegexReplacementList() by default (i.e. empty)
    value_replacements: RegexReplacementList  # = cpp_to_python.standard_value_replacements() by default
    comments_replacements: RegexReplacementList  # = cpp_to_python.standard_comment_replacements() by default
    macro_name_replacements: RegexReplacementList  # = RegexReplacementList() by default (i.e. empty)

    ################################################################################
    #    <functions and method adaptations>
    ################################################################################

    # ------------------------------------------------------------------------------
    # Exclude some functions
    # ------------------------------------------------------------------------------
    # Exclude certain functions and methods by a regex on their name
    fn_exclude_by_name__regex: str = ""

    # Exclude certain functions and methods by a regex on any of their parameter type and/or return type
    # (those should be decorated type)
    # For example:
    #     options.fn_exclude_by_param_type__regex = "^char\s*\$|^unsigned\s+char\$|Callback\$"
    # would exclude all functions having params of type "char *", "unsigned char", "xxxCallback"
    #
    # Note: this is distinct from \`fn_params_exclude_types__regex\` which removes params
    # from the function signature, but not the function itself.
    fn_exclude_by_param_type__regex: str = ""

    # Exclude function and methods by its name and signature
    # For example:
    #    options.fn_exclude_by_name_and_signature = {
    #         "Selectable": "const char *, bool, ImGuiSelectableFlags, const ImVec2 &"
    #     }
    fn_exclude_by_name_and_signature: dict[str, str]

    # ------------------------------------------------------------------------------
    # Exclude some params by name or type
    # ------------------------------------------------------------------------------
    # Remove some params from the python published interface. A param can only be removed if it has a default value
    # in the C++ signature
    fn_params_exclude_names__regex: str = ""
    fn_params_exclude_types__regex: str = ""

    # fn_exclude_non_api:
    # if srcmlcpp_options.functions_api_prefixes is filled, and fn_exclude_non_api=True,
    # then only functions with an api marker will be exported.
    fn_exclude_non_api: bool = True
    # fn_non_api_comment:
    # if fn_exclude_non_api is False, a comment can be added to non api functions in the stub file
    fn_non_api_comment: str = "(private API)"

    # ------------------------------------------------------------------------------
    # Templated functions options
    # ------------------------------------------------------------------------------
    # Template function must be instantiated for the desired types.
    # See https://pybind11.readthedocs.io/en/stable/advanced/functions.html#binding-functions-with-template-parameters
    #
    # fn_template_options:
    #    of type Dict[ TemplatedFunctionNameRegexStr (aka str), List[CppTypeName] ]
    #
    # For example,
    # 1. This line:
    #        options.fn_template_options.add_specialization(r"template^", ["int", double"])
    #    would instantiate all template functions whose name end with "template" with "int" and "double"
    # 2. This line:
    #        options.fn_template_options.add_specialization(r".*", ["int", float"])
    #    would instantiate all template functions (whatever their name) with "int" and "float"
    # 3. This line:
    #        options.fn_template_options.add_ignore(r".*")
    #    would ignore all template functions (they will not be exported)
    fn_template_options: TemplateFunctionsOptions
    # if fn_template_decorate_in_stub is True, then there will be some
    # decorative comments in the stub file, in order to visually group
    # the generated functions together
    fn_template_decorate_in_stub: bool = True

    # ------------------------------------------------------------------------------
    # Vectorize functions options (pybind11 only, not compatible with nanobind)
    # ------------------------------------------------------------------------------
    # Numeric functions (i.e. function accepting and returning only numeric params or py::array), can be vectorized
    # i.e. they will accept numpy arrays as an input.
    # See https://pybind11.readthedocs.io/en/stable/advanced/pycpp/numpy.html#vectorizing-functions
    # and https://github.com/pybind/pybind11/blob/master/tests/test_numpy_vectorize.cpp
    #
    # * fn_vectorize__regex and fn_namespace_vectorize__regex contain a regexes
    # on functions names + namespace names for which this transformation will be applied.
    #
    # For example, to vectorize all function of the namespace MathFunctions, apply these options:
    #     options.fn_namespace_vectorize__regex: str = r"MathFunctions^\$"
    #     options.fn_vectorize__regex = r".*"
    #
    # * fn_vectorize_prefix and fn_vectorize_suffix will be added to the vectorized functions names
    #   (they can be empty, in which case the vectorized function will be a usable overload with the same name)
    fn_vectorize__regex: str = r""
    fn_namespace_vectorize__regex: str = r""
    fn_vectorize_prefix: str = ""
    fn_vectorize_suffix: str = ""

    # ------------------------------------------------------------------------------
    # Return policy
    # ------------------------------------------------------------------------------
    # Force the function that match those regexes to use \`pybind11::return_value_policy::reference\`
    #
    # Note:
    #    you can also write "// py::return_value_policy::reference" as an end of line comment after the function.
    #    See packages/litgen/integration_tests/mylib/include/mylib/return_value_policy_test.h as an example
    fn_return_force_policy_reference_for_pointers__regex: str = ""
    fn_return_force_policy_reference_for_references__regex: str = ""

    # ------------------------------------------------------------------------------
    # Force overload
    # ------------------------------------------------------------------------------
    # Force using py::overload for functions that matches these regexes
    fn_force_overload__regex: str = ""
    # Force using a lambda for functions that matches these regexes
    # (useful when pybind11 is confused and gives error like
    #     error: no matching function for call to object of type 'const detail::overload_cast_impl<...>'
    fn_force_lambda__regex: str = ""

    # ------------------------------------------------------------------------------
    # C style buffers to py::array
    # ------------------------------------------------------------------------------
    #
    # Signatures with a C buffer like this:
    #       MY_API inline void add_inside_array(uint8_t* array, size_t array_size, uint8_t number_to_add)
    # may be transformed to:
    #       void add_inside_array(py::array & array, uint8_t number_to_add)              (c++ bound signature)
    #       def add_inside_array(array: numpy.ndarray, number_to_add: int) -> None       (python)
    #
    # It also works for templated buffers:
    #       MY_API template<typename T> void mul_inside_array(T* array, size_t array_size, double factor)
    # will be transformed to:
    #       void mul_inside_array(py::array & array, double factor)                      (c++ bound signature)
    #       def mul_inside_array(array: numpy.ndarray, factor: float) -> None            (python)
    # (and factor will be down-casted to the target type)
    #
    # fn_params_buffer_replace_by_array_regexes contains a regex on functions names
    # for which this transformation will be applied.
    # Set it to r".*" to apply this to all functions, set it to "" to disable it
    #
    fn_params_replace_buffer_by_array__regex: str = r""

    # fn_params_buffer_types: list of numeric types that are considered as possible buffers.
    # You can customize this list in your own options by removing items from it,
    # but you *cannot* add new types or new synonyms (typedef for examples); since the conversion between
    # py::array and native relies on these *exact* names!
    #
    # By default, fn_params_buffer_types will contain those types:
    fn_params_buffer_types: str = code_utils.join_string_by_pipe_char(
        [
            "uint8_t",
            "int8_t",
            "uint16_t",
            "int16_t",
            "uint32_t",
            "int32_t",
            "np_uint_l",  # Platform dependent: "uint64_t" on *nixes, "uint32_t" on windows
            "np_int_l",  # Platform dependent: "int64_t" on *nixes, "int32_t" on windows
            "float",
            "double",
            "long double",
            "long long",
        ]
    )

    # fn_params_buffer_template_types: list of templated names that are considered as possible templated buffers
    # By default, only template<typename T> or template<typename NumericType> are accepted
    fn_params_buffer_template_types: str = code_utils.join_string_by_pipe_char(["T", "NumericType"])

    # fn_params_buffer_size_names__regex: possible names for the size of the buffer
    # = ["nb", "size", "count", "total", "n"] by default
    fn_params_buffer_size_names__regex: str = code_utils.join_string_by_pipe_char(
        [
            code_utils.make_regex_var_name_contains_word("nb"),
            code_utils.make_regex_var_name_contains_word("size"),
            code_utils.make_regex_var_name_contains_word("count"),
            code_utils.make_regex_var_name_contains_word("total"),
            code_utils.make_regex_var_name_contains_word("n"),
        ]
    )

    # ------------------------------------------------------------------------------
    # C style arrays functions and methods parameters
    # ------------------------------------------------------------------------------
    #
    # Signatures like
    #       void foo_const(const int input[2])
    # may be transformed to:
    #       void foo_const(const std::array<int, 2>& input)    (c++ bound signature)
    #       def foo_const(input: List[int]) -> None:           (python)
    # fn_params_replace_c_array_const_by_std_array__regex contains a list of regexes on functions names
    # for which this transformation will be applied.
    # Set it to r".*" to apply this to all functions, set it to "" to disable it
    fn_params_replace_c_array_const_by_std_array__regex: str = r".*"

    # Signatures like
    #       void foo_non_const(int output[2])
    # may be transformed to:
    #       void foo_non_const(BoxedInt & output_0, BoxedInt & output_1)         (c++ bound signature)
    #       def foo_non_const(output_0: BoxedInt, output_0: BoxedInt) -> None    (python)
    # fn_params_replace_c_array_modifiable_by_boxed__regex contains a list of regexes on functions names
    # for which this transformation will be applied.
    # Set it to r".*" to apply this to all functions, set it to "" to disable it
    fn_params_replace_c_array_modifiable_by_boxed__regex: str = r".*"
    # (c_array_modifiable_max_size is the maximum number of params that can be boxed like this)
    fn_params_replace_modifiable_c_array__max_size = 10

    # ------------------------------------------------------------------------------
    # C style string list functions and methods parameters
    # ------------------------------------------------------------------------------
    # Signatures like
    #     void foo(const char * const items[], int items_count)
    # may be transformed to:
    #     void foo(const std::vector<std::string>& const items[])        (c++ bound signature)
    #     def foo(items: List[str]) -> None                              (python)
    # fn_params_replace_c_string_list_regexes contains a list of regexes on functions names
    # for which this transformation will be applied.
    # Set it to [r".*"] to apply this to all functions, set it to [] to disable it
    fn_params_replace_c_string_list__regex: str = r".*"

    # ------------------------------------------------------------------------------
    # Make "immutable python types" modifiable, when passed by pointer or reference
    # ------------------------------------------------------------------------------
    #
    # adapt functions params that use non const pointers or reference to a type that is immutable in python.

    # Signatures like
    #     int foo(int* value)
    # May be transformed to:
    #     def foo(BoxedInt value) -> int                                  (python)
    # So that any modification done on the C++ side can be seen from python.
    #
    # fn_params_adapt_modifiable_immutable_regexes contains a list of regexes on functions names
    # Set it to r".*" to apply this to all functions. Set it to "" to disable it
    fn_params_replace_modifiable_immutable_by_boxed__regex: str = r""

    # ------------------------------------------------------------------------------
    # Make "mutable default parameters" behave like C++ default arguments
    # (i.e. re-evaluate the default value each time the function is called)
    # ------------------------------------------------------------------------------
    # Regex which contains a list of regexes on functions names for which this transformation will be applied.
    # by default, this is disabled (set it to r".*" to enable it for all functions)
    fn_params_adapt_mutable_param_with_default_value__regex: str = r""
    # if True, auto-generated named constructors will adapt mutable default parameters
    fn_params_adapt_mutable_param_with_default_value__to_autogenerated_named_ctor: bool = False
    # if True, a comment will be added in the stub file to explain the behavior
    fn_params_adapt_mutable_param_with_default_value__add_comment: bool = True
    # fn_params_adapt_mutable_param_with_default_value__fn_is_known_immutable_type
    # may contain a user defined function that will determine if a type is considered immutable in python based on its name.
    # By default, all the types below are considered immutable in python:
    #     "int|float|double|bool|char|unsigned char|std::string|..."
    fn_params_adapt_mutable_param_with_default_value__fn_is_known_immutable_type: Callable[[str], bool] | None = None
    # Same as above, but for values
    fn_params_adapt_mutable_param_with_default_value__fn_is_known_immutable_value: Callable[[str], bool] | None = None

    # ------------------------------------------------------------------------------
    # Convert \`const char* x = NULL\` for Python passing None without TypeError
    # ------------------------------------------------------------------------------
    # Signatures like
    #     void foo(const char* text = NULL)
    # may be transformed to:
    #     void foo(std::optional<std::string> text = std::nullopt)
    # with a lambda function wrapping around original interface.
    #
    # NOTE: Enable this for nanobind.
    fn_params_const_char_pointer_with_default_null: bool = True

    # As an alternative, we can also add the modified value to the returned type
    # of the function (which will now be a tuple)
    #
    # For example
    #     int foo(int* value)
    # May be transformed to:
    #     def foo(int value) -> Tuple[int, bool]
    # So that any modification done on the C++ side can be seen from python.
    #
    # fn_params_output_modifiable_immutable_to_return__regex contains a list of regexes on functions names
    # Set it to r".*" to apply this to all functions. Set it to "" to disable it
    fn_params_output_modifiable_immutable_to_return__regex: str = ""

    # ------------------------------------------------------------------------------
    # Custom adapters (advanced, very advanced and not documented here)
    # fn_custom_adapters may contain callables of signature
    #   f(adapted_function: AdaptedFunction) -> Optional[LambdaAdapter]
    # ------------------------------------------------------------------------------
    fn_custom_adapters: list[Any]

    ################################################################################
    #    <class, struct, and member adaptations>
    ################################################################################

    # Exclude certain classes and structs by a regex on their name
    class_exclude_by_name__regex: str = ""
    # Exclude certain members by a regex on their name
    member_exclude_by_name__regex: str = ""
    # Exclude members based on their type
    member_exclude_by_type__regex: str = ""
    # Exclude certain members by a regex on their name, if class or struct name matched
    # For example:
    #   options.member_exclude_by_name_and_class__regex = {
    #       "ImVector": join_string_by_pipe_char([
    #           r"^Size\$",
    #           r"^Capacity\$",
    #           ...
    #       ])
    #   }
    member_exclude_by_name_and_class__regex: dict[str, str]

    # Make certain members read-only by a regex on their name
    member_readonly_by_name__regex: str = ""
    # Make certain members read-only based on their type
    member_readonly_by_type__regex: str = ""

    # class_create_default_named_ctor__regex / struct_create_default_named_ctor__regex:
    # regex giving the list of class & struct names for which we want to generate a named
    # constructor for Python, when no default constructor is provided by C++
    # (by default, this is active for all structs and not for the classes,
    #  in order for it to work, all struct members need to be default constructible if
    #  they are not declared with a default value)
    struct_create_default_named_ctor__regex: str = r".*"
    class_create_default_named_ctor__regex: str = r""

    # class_expose_protected_methods__regex:
    # regex giving the list of class names for which we want to expose protected methods.
    # (by default, only public methods are exposed)
    # If active, this will use the technique described at
    # https://pybind11.readthedocs.io/en/stable/advanced/classes.html#binding-protected-member-functions)
    class_expose_protected_methods__regex: str = ""

    # class_expose_protected_methods__regex:
    # regex giving the list of class names for which we want to be able to override virtual methods
    # from python.
    # (by default, this is not possible)
    # If active, this will use the technique described at
    # https://pybind11.readthedocs.io/en/stable/advanced/classes.html#overriding-virtual-functions-in-python
    #
    # Note: if you want to override protected functions, also fill \`class_expose_protected_methods__regex\`
    class_override_virtual_methods_in_python__regex: str = ""

    # class_dynamic_attributes__regex
    # By default, classes exported from C++ do not support dynamic attributes and the only writable attributes are
    # the ones explicitly defined using class_::def_readwrite() or class_::def_property().
    # If active, this will use the technique described at
    # https://pybind11.readthedocs.io/en/stable/classes.html#dynamic-attributes
    class_dynamic_attributes__regex: str = ""

    # class_deep_copy__regex & class_copy__regex:
    # By default, structs and classes exported from C++ do not support (deep)copy.
    # However, if they do have a copy constructor (implicit or user defined),
    # (deep)copy can be enabled by invoking this constructor.
    # https://pybind11.readthedocs.io/en/stable/advanced/classes.html#deepcopy-support
    class_deep_copy__regex: str = ""
    class_copy__regex: str = ""
    # If class_copy_add_info_in_stub=True, the existence of __copy__ and __deepcopy__
    # will be mentioned in the stub file.
    class_copy_add_info_in_stub: bool = False

    # iterable classes: if some cpp classes expose begin()/end()/size(), they can be made iterable in python
    # Make classes iterables by setting:
    #     options.class_iterables_infos.add_iterable_class(python_class_name__regex, iterable_python_type_name)
    class_iterables_infos: ClassIterablesInfos

    # class_held_as_shared__regex:
    # Regex specifying the list of class names that should be held using std::shared_ptr in the generated bindings
    # (when using pybind11. This is unused for nanobind)
    #
    # **Purpose:**
    # By default, pybind11 uses \`std::unique_ptr\` as the holder type for bound classes.
    #
    # **When to Use:**
    # If your C++ code uses \`std::shared_ptr\` to manage instances of a class (e.g., as member variables, return types,
    # or parameters), and you expose that class to Python, you need to ensure that pybind11 uses \`std::shared_ptr\` as
    # the holder type for that class.
    #
    # **References:**
    # - [pybind11 Documentation: Smart Pointers](https://pybind11.readthedocs.io/en/stable/advanced/smart_ptrs.html)
    # - [Understanding Holder Types in pybind11](https://pybind11.readthedocs.io/en/stable/advanced/classes.html#custom-smart-pointers)
    class_held_as_shared__regex: str = ""

    # ------------------------------------------------------------------------------
    # Templated class options
    # ------------------------------------------------------------------------------
    # Template class must be instantiated for the desired types, and a new name must be given for each instantiation
    # See https://pybind11.readthedocs.io/en/stable/advanced/classes.html#binding-classes-with-template-parameters
    #
    # class_template_options enables to set this
    #
    # For example
    # 1. this call would instantiate some classes for types "int" and "const char *", with a naming scheme:
    #   MyClass<int> (cpp)  -> MyClassInt (python)
    #   ------------------------------------------
    #     options.class_template_options.add_specialization(
    #         class_name_regex=r"^MyPrefix",                 # r"^MyPrefix" => select class names with this prefix
    #         cpp_types_list=["int", "const char *"],        # instantiated types
    #         naming_scheme=TemplateNamingScheme.camel_case_suffix
    #     )
    # 2. this call would ignore all template classes:
    #        options.class_template_options.add_ignore(r".*")
    #    would ignore all template functions (they will not be exported)
    class_template_options: TemplateClassOptions
    # if class_template_decorate_in_stub is True, then there will be some
    # decorative comments in the stub file, in order to visually group
    # the generated classes together
    class_template_decorate_in_stub: bool = True

    # ------------------------------------------------------------------------------
    # Adapt class members
    # ------------------------------------------------------------------------------
    # adapt class members which are a fixed size array of a numeric type:
    #
    # For example
    #       struct Foo {  int values[10]; };
    # May be transformed to:
    #       class Foo:
    #           values: numpy.ndarray
    #
    # i.e. the member will be transformed to a property that points to a numpy array
    # which can be read/written from python (this requires numpy)
    # This is active by default.
    member_numeric_c_array_replace__regex: str = r".*"

    # member_numeric_c_array_types: list of numeric types that can be stored in a numpy array
    # for a class member which is a fixed size array of a numeric type
    # - Synonyms (defined via. \`typedef\` or \`using\`) are allowed here
    # - *don't* include char, *don't* include byte, those are not numeric!
    #   See https://numpy.org/doc/stable/reference/generated/numpy.chararray.html
    member_numeric_c_array_types: str = code_utils.join_string_by_pipe_char(
        [
            "int",
            "unsigned int",
            "long",
            "unsigned long",
            "long long",
            "unsigned long long",
            "float",
            "double",
            "long double",
            "uint8_t",
            "int8_t",
            "uint16_t",
            "int16_t",
            "uint32_t",
            "int32_t",
            "uint64_t",
            "int64_t",
            "bool",
        ]
    )

    ################################################################################
    #    <namespace adaptations>
    ################################################################################

    # All C++ namespaces in this list will not be emitted as a submodule
    # (i.e. their inner code will be placed in the root python module, or in the parent
    # module)
    namespaces_root: List[str]

    # All C++ namespaces that match this regex will be excluded
    # By default, any namespace whose name contains "internal" or "detail" will be excluded.
    namespace_exclude__regex = r"[Ii]nternal|[Dd]etail"

    ################################################################################
    #    <enum adaptations>
    ################################################################################
    # Exclude certain enums by a regex on their name
    enum_exclude_by_name__regex: str = ""
    # Remove the typical "EnumName_" prefix from "C enum" values.
    # For example, with the C enum:
    #     enum MyEnum { MyEnum_A = 0, MyEnum_B };
    # Values would be named "a" and "b" in python
    enum_flag_remove_values_prefix: bool = True
    # A specific case for ImGui, which defines private enums which may extend the public ones:
    #     enum ImGuiMyFlags_ { ImGuiMyFlags_None = 0,...};  enum ImGuiMyFlagsPrivate_ { ImGuiMyFlags_PrivValue = ...};
    enum_flag_remove_values_prefix_group_private: bool = False

    # Skip count value from enums, for example like in:
    #    enum MyEnum { MyEnum_A = 1, MyEnum_B = 1, MyEnum_COUNT };
    enum_flag_skip_count: bool = True
    # By default, all enums export rudimentary arithmetic and bit-level operations ( r".*" matches any enum name)
    enum_make_arithmetic__regex: str = r".*"
    # Export all entries of the enumeration into the parent scope.
    enum_export_values: bool = False

    ################################################################################
    #    <define adaptations>
    ################################################################################
    # Simple preprocessor defines can be exported as global variables, e.g.:
    #     #define MY_VALUE 1
    #     #define MY_FLOAT 1.5
    #     #define MY_STRING "abc"
    #     #define MY_HEX_VALUE 0x00010009
    # This is limited to *simple* defines (no param, string, int, float or hex only)
    # By default nothing is exported
    macro_define_include_by_name__regex: str = ""

    ################################################################################
    #    <globals vars adaptations>
    ################################################################################
    # Global variable defines can be exported as global variables, e.g.:
    # By default nothing is exported (still experimental)
    globals_vars_include_by_name__regex: str = ""

    ################################################################################
    #    <post processing>
    ################################################################################
    # If you need to process the code after generation, fill these functions
    postprocess_stub_function: Callable[[str], str] | None = None  # run at the very end
    postprocess_pydef_function: Callable[[str], str] | None = None

    ################################################################################
    #    <Sanity checks and utilities below>
    ################################################################################
    def check_options_consistency(self) -> None:
        # the only authorized type are those for which the size is known with certainty
        # * int and long are not acceptable candidates: use int8_t, uint_8t, int32_t, etc.
        # * concerning float and doubles, there is no standard for fixed size floats, so we have to cope with
        #   float, double and long double and their various platforms implementations...
        authorized_types = [
            "byte",
            "uint8_t",
            "int8_t",
            "uint16_t",
            "int16_t",
            "uint32_t",
            "int32_t",
            "np_uint_l",  # Platform dependent: "uint64_t" on *nixes, "uint32_t" on windows
            "np_int_l",  # Platform dependent: "int64_t" on *nixes, "int32_t" on windows
            "float",
            "double",
            "long double",
            "long long",
        ]
        for buffer_type in self._fn_params_buffer_types_list():
            if buffer_type not in authorized_types:
                raise ValueError(
                    f"""
                    options.build_types contains an unauthorized type: {buffer_type}
                    Authorized types are: { ", ".join(authorized_types) }
                    """
                )

    def _indent_cpp_spaces(self) -> str:
        space = "\t" if self.cpp_indent_with_tabs else " "
        return space * self.cpp_indent_size

    def _indent_python_spaces(self) -> str:
        space = "\t" if self.python_ident_with_tabs else " "
        return space * self.python_indent_size

    def _fn_params_buffer_types_list(self) -> list[str]:
        return code_utils.split_string_by_pipe_char(self.fn_params_buffer_types)

    def _fn_params_buffer_template_types_list(self) -> list[str]:
        return code_utils.split_string_by_pipe_char(self.fn_params_buffer_template_types)

    def _member_numeric_c_array_types_list(self) -> list[str]:
        return code_utils.split_string_by_pipe_char(self.member_numeric_c_array_types)

    def __init__(self) -> None:
        # See doc for all the params at their declaration site (scroll up to the top of this file!)
        from litgen.internal import cpp_to_python

        self.srcmlcpp_options = SrcmlcppOptions()
        self.srcmlcpp_options.header_filter_preprocessor_regions = True

        self.type_replacements = cpp_to_python.standard_type_replacements()
        self.value_replacements = cpp_to_python.standard_value_replacements()
        self.comments_replacements = cpp_to_python.standard_comment_replacements()

        self.function_names_replacements = RegexReplacementList()
        self.var_names_replacements = RegexReplacementList()
        self.macro_name_replacements = RegexReplacementList()
        self.namespace_names_replacements = RegexReplacementList()

        self.fn_template_options = TemplateFunctionsOptions()
        self.class_template_options = TemplateClassOptions()

        self.class_iterables_infos = ClassIterablesInfos()

        self.fn_custom_adapters = []
        self.namespaces_root = []

        self.fn_exclude_by_name_and_signature = {}
        self.member_exclude_by_name_and_class__regex = {}
`;
            navigator.clipboard.writeText(code);
       }
    </script>
    <button class="collapsible_header" id="btn_1731710856063_79_0" >litgen/options.py</button>
    <div class="collapsible_content" id="content_1731710856063_79_0">
        <div>
                <button onclick="copy_code_1731710856063_79()" align="right">copy &#x270d;</button>
        </div>
        <style>pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #3c3836 }
.highlight { background: #fbf1c7; }
.highlight .c { color: #928374; font-style: italic } /* Comment */
.highlight .err { color: #fbf1c7; background-color: #9d0006 } /* Error */
.highlight .k { color: #9d0006 } /* Keyword */
.highlight .ch { color: #928374; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #928374; font-style: italic } /* Comment.Multiline */
.highlight .c-PreProc { color: #427b58; font-style: italic } /* Comment.PreProc */
.highlight .cp { color: #928374; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #928374; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #928374; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3c3836; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #fbf1c7; background-color: #9d0006 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #9d0006 } /* Generic.Error */
.highlight .gh { color: #3c3836; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #fbf1c7; background-color: #79740e } /* Generic.Inserted */
.highlight .go { color: #32302f } /* Generic.Output */
.highlight .gp { color: #7c6f64 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #3c3836; text-decoration: underline } /* Generic.Subheading */
.highlight .gt { color: #9d0006 } /* Generic.Traceback */
.highlight .kc { color: #9d0006 } /* Keyword.Constant */
.highlight .kd { color: #9d0006 } /* Keyword.Declaration */
.highlight .kn { color: #9d0006 } /* Keyword.Namespace */
.highlight .kp { color: #9d0006 } /* Keyword.Pseudo */
.highlight .kr { color: #9d0006 } /* Keyword.Reserved */
.highlight .kt { color: #9d0006 } /* Keyword.Type */
.highlight .m { color: #8f3f71 } /* Literal.Number */
.highlight .s { color: #79740e } /* Literal.String */
.highlight .na { color: #b57614 } /* Name.Attribute */
.highlight .nb { color: #af3a03 } /* Name.Builtin */
.highlight .nc { color: #427b58 } /* Name.Class */
.highlight .no { color: #8f3f71 } /* Name.Constant */
.highlight .nd { color: #9d0006 } /* Name.Decorator */
.highlight .ne { color: #9d0006 } /* Name.Exception */
.highlight .nf { color: #427b58 } /* Name.Function */
.highlight .nn { color: #427b58 } /* Name.Namespace */
.highlight .nt { color: #427b58 } /* Name.Tag */
.highlight .nv { color: #076678 } /* Name.Variable */
.highlight .ow { color: #9d0006 } /* Operator.Word */
.highlight .mb { color: #8f3f71 } /* Literal.Number.Bin */
.highlight .mf { color: #8f3f71 } /* Literal.Number.Float */
.highlight .mh { color: #8f3f71 } /* Literal.Number.Hex */
.highlight .mi { color: #8f3f71 } /* Literal.Number.Integer */
.highlight .mo { color: #8f3f71 } /* Literal.Number.Oct */
.highlight .sa { color: #79740e } /* Literal.String.Affix */
.highlight .sb { color: #79740e } /* Literal.String.Backtick */
.highlight .sc { color: #79740e } /* Literal.String.Char */
.highlight .dl { color: #79740e } /* Literal.String.Delimiter */
.highlight .sd { color: #79740e } /* Literal.String.Doc */
.highlight .s2 { color: #79740e } /* Literal.String.Double */
.highlight .se { color: #af3a03 } /* Literal.String.Escape */
.highlight .sh { color: #79740e } /* Literal.String.Heredoc */
.highlight .si { color: #79740e } /* Literal.String.Interpol */
.highlight .sx { color: #79740e } /* Literal.String.Other */
.highlight .sr { color: #79740e } /* Literal.String.Regex */
.highlight .s1 { color: #79740e } /* Literal.String.Single */
.highlight .ss { color: #79740e } /* Literal.String.Symbol */
.highlight .bp { color: #af3a03 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #427b58 } /* Name.Function.Magic */
.highlight .vc { color: #076678 } /* Name.Variable.Class */
.highlight .vg { color: #076678 } /* Name.Variable.Global */
.highlight .vi { color: #076678 } /* Name.Variable.Instance */
.highlight .vm { color: #076678 } /* Name.Variable.Magic */
.highlight .il { color: #8f3f71 } /* Literal.Number.Integer.Long */</style> <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">codemanip</span> <span class="kn">import</span> <span class="n">code_utils</span>
<span class="kn">from</span> <span class="nn">codemanip.code_replacements</span> <span class="kn">import</span> <span class="n">RegexReplacementList</span>

<span class="kn">from</span> <span class="nn">srcmlcpp</span> <span class="kn">import</span> <span class="n">SrcmlcppOptions</span>

<span class="kn">from</span> <span class="nn">litgen.internal.template_options</span> <span class="kn">import</span> <span class="n">TemplateFunctionsOptions</span><span class="p">,</span> <span class="n">TemplateClassOptions</span>
<span class="kn">from</span> <span class="nn">litgen.internal.class_iterable_info</span> <span class="kn">import</span> <span class="n">ClassIterablesInfos</span>


<span class="k">class</span> <span class="nc">BindLibraryType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">pybind11</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nanobind</span> <span class="o">=</span> <span class="mi">2</span>


<span class="k">class</span> <span class="nc">LitgenOptions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numerous options to configure litgen code generation.</span>

<span class="sd">    (include / excludes, indentation, c++ to python translation settings, function parameters</span>
<span class="sd">    adaptations, etc.)&quot;&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Note about regexes below:</span>
    <span class="c1"># =========================</span>
    <span class="c1"># - regexes can support several alternatives: separate them by &quot;|&quot;</span>
    <span class="c1"># For example, in order to match an exact function name, as well as functions ending with &quot;_private&quot;,</span>
    <span class="c1"># use a regex like this:</span>
    <span class="c1">#         r&quot;^YourFunctionName$|_private$&quot;,</span>
    <span class="c1"># - If a regex string is empty, it will not match anything</span>
    <span class="c1"># - To match everything, use r&quot;.*&quot;</span>
    <span class="c1"># - It is advised to prefix your regex strings with &quot;r&quot; (in order to use raw strings)</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;bind library options&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1">#</span>
    <span class="n">bind_library</span><span class="p">:</span> <span class="n">BindLibraryType</span> <span class="o">=</span> <span class="n">BindLibraryType</span><span class="o">.</span><span class="n">pybind11</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;srcmlcpp options&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1"># There are interesting options to set in SrcmlcppOptions (see srcmlcpp/srcmlcpp_options.py)</span>
    <span class="c1">#</span>
    <span class="c1"># Notably:</span>
    <span class="c1"># * fill srcmlcpp_options.functions_api_prefixes: the prefix(es) that denotes exported dll functions</span>
    <span class="c1"># * also set LitgenOptions.fn_exclude_non_api=True if you want to exclude non api functions and methods</span>
    <span class="n">srcmlcpp_options</span><span class="p">:</span> <span class="n">SrcmlcppOptions</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Layout settings for the generated python stub code&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;show the original location and or signature of elements as a comment&gt;</span>
    <span class="n">original_location_flag_show</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># if showing location, how many parent folders shall be shown</span>
    <span class="c1"># (if -1, show the full path)</span>
    <span class="n">original_location_nb_parent_folders</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># If True, the complete C++ original signature will be show as a comment in the python stub (pyi)</span>
    <span class="n">original_signature_flag_show</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Size of an indentation in the python stubs</span>
    <span class="n">python_indent_size</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">python_ident_with_tabs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Insert as many empty lines in the python stub as found in the header file, keep comments layout, etc.</span>
    <span class="n">python_reproduce_cpp_layout</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># The generated code will try to adhere to this max length (if negative, this is ignored)</span>
    <span class="n">python_max_line_length</span> <span class="o">=</span> <span class="mi">88</span>
    <span class="c1"># Strip (remove) empty comment lines</span>
    <span class="n">python_strip_empty_comment_lines</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Run black formatter</span>
    <span class="n">python_run_black_formatter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">python_black_formatter_line_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">88</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Layout settings for the C++ generated pydef code&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1"># Spacing option in C++ code</span>
    <span class="n">cpp_indent_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">cpp_indent_with_tabs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Disable comments inclusion in C++ and Python&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="n">comments_exclude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;names translation from C++ to python&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1"># Convert variables, functions and namespaces names to snake_case (class, structs, and enums names are always preserved)</span>
    <span class="n">python_convert_to_snake_case</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># List of code replacements when going from C++ to Python</span>
    <span class="c1"># Notes:</span>
    <span class="c1"># - by default, type_replacements is prefilled with standard_type_replacements()</span>
    <span class="c1">#   type_replacements will be applied to all types (including class and enum names)</span>
    <span class="c1"># - by default, value_replacements is prefilled with standard_value_replacements()</span>
    <span class="c1"># - by default, comments_replacements is prefilled with standard_comments_replacements()</span>
    <span class="c1"># - by default, the others are empty</span>
    <span class="c1"># - type_replacements, var_names_replacements and function_names_replacements enable you</span>
    <span class="c1">#   to modify the outputted python code</span>
    <span class="n">type_replacements</span><span class="p">:</span> <span class="n">RegexReplacementList</span>  <span class="c1"># = cpp_to_python.standard_type_replacements() by default</span>
    <span class="n">var_names_replacements</span><span class="p">:</span> <span class="n">RegexReplacementList</span>  <span class="c1"># = RegexReplacementList() by default (i.e. empty)</span>
    <span class="n">namespace_names_replacements</span><span class="p">:</span> <span class="n">RegexReplacementList</span>  <span class="c1"># = RegexReplacementList() by default (i.e. empty)</span>
    <span class="n">function_names_replacements</span><span class="p">:</span> <span class="n">RegexReplacementList</span>  <span class="c1"># = RegexReplacementList() by default (i.e. empty)</span>
    <span class="n">value_replacements</span><span class="p">:</span> <span class="n">RegexReplacementList</span>  <span class="c1"># = cpp_to_python.standard_value_replacements() by default</span>
    <span class="n">comments_replacements</span><span class="p">:</span> <span class="n">RegexReplacementList</span>  <span class="c1"># = cpp_to_python.standard_comment_replacements() by default</span>
    <span class="n">macro_name_replacements</span><span class="p">:</span> <span class="n">RegexReplacementList</span>  <span class="c1"># = RegexReplacementList() by default (i.e. empty)</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;functions and method adaptations&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Exclude some functions</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Exclude certain functions and methods by a regex on their name</span>
    <span class="n">fn_exclude_by_name__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># Exclude certain functions and methods by a regex on any of their parameter type and/or return type</span>
    <span class="c1"># (those should be decorated type)</span>
    <span class="c1"># For example:</span>
    <span class="c1">#     options.fn_exclude_by_param_type__regex = &quot;^char\s*$|^unsigned\s+char$|Callback$&quot;</span>
    <span class="c1"># would exclude all functions having params of type &quot;char *&quot;, &quot;unsigned char&quot;, &quot;xxxCallback&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># Note: this is distinct from `fn_params_exclude_types__regex` which removes params</span>
    <span class="c1"># from the function signature, but not the function itself.</span>
    <span class="n">fn_exclude_by_param_type__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># Exclude function and methods by its name and signature</span>
    <span class="c1"># For example:</span>
    <span class="c1">#    options.fn_exclude_by_name_and_signature = {</span>
    <span class="c1">#         &quot;Selectable&quot;: &quot;const char *, bool, ImGuiSelectableFlags, const ImVec2 &amp;&quot;</span>
    <span class="c1">#     }</span>
    <span class="n">fn_exclude_by_name_and_signature</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Exclude some params by name or type</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Remove some params from the python published interface. A param can only be removed if it has a default value</span>
    <span class="c1"># in the C++ signature</span>
    <span class="n">fn_params_exclude_names__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">fn_params_exclude_types__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># fn_exclude_non_api:</span>
    <span class="c1"># if srcmlcpp_options.functions_api_prefixes is filled, and fn_exclude_non_api=True,</span>
    <span class="c1"># then only functions with an api marker will be exported.</span>
    <span class="n">fn_exclude_non_api</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># fn_non_api_comment:</span>
    <span class="c1"># if fn_exclude_non_api is False, a comment can be added to non api functions in the stub file</span>
    <span class="n">fn_non_api_comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;(private API)&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Templated functions options</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Template function must be instantiated for the desired types.</span>
    <span class="c1"># See https://pybind11.readthedocs.io/en/stable/advanced/functions.html#binding-functions-with-template-parameters</span>
    <span class="c1">#</span>
    <span class="c1"># fn_template_options:</span>
    <span class="c1">#    of type Dict[ TemplatedFunctionNameRegexStr (aka str), List[CppTypeName] ]</span>
    <span class="c1">#</span>
    <span class="c1"># For example,</span>
    <span class="c1"># 1. This line:</span>
    <span class="c1">#        options.fn_template_options.add_specialization(r&quot;template^&quot;, [&quot;int&quot;, double&quot;])</span>
    <span class="c1">#    would instantiate all template functions whose name end with &quot;template&quot; with &quot;int&quot; and &quot;double&quot;</span>
    <span class="c1"># 2. This line:</span>
    <span class="c1">#        options.fn_template_options.add_specialization(r&quot;.*&quot;, [&quot;int&quot;, float&quot;])</span>
    <span class="c1">#    would instantiate all template functions (whatever their name) with &quot;int&quot; and &quot;float&quot;</span>
    <span class="c1"># 3. This line:</span>
    <span class="c1">#        options.fn_template_options.add_ignore(r&quot;.*&quot;)</span>
    <span class="c1">#    would ignore all template functions (they will not be exported)</span>
    <span class="n">fn_template_options</span><span class="p">:</span> <span class="n">TemplateFunctionsOptions</span>
    <span class="c1"># if fn_template_decorate_in_stub is True, then there will be some</span>
    <span class="c1"># decorative comments in the stub file, in order to visually group</span>
    <span class="c1"># the generated functions together</span>
    <span class="n">fn_template_decorate_in_stub</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Vectorize functions options (pybind11 only, not compatible with nanobind)</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Numeric functions (i.e. function accepting and returning only numeric params or py::array), can be vectorized</span>
    <span class="c1"># i.e. they will accept numpy arrays as an input.</span>
    <span class="c1"># See https://pybind11.readthedocs.io/en/stable/advanced/pycpp/numpy.html#vectorizing-functions</span>
    <span class="c1"># and https://github.com/pybind/pybind11/blob/master/tests/test_numpy_vectorize.cpp</span>
    <span class="c1">#</span>
    <span class="c1"># * fn_vectorize__regex and fn_namespace_vectorize__regex contain a regexes</span>
    <span class="c1"># on functions names + namespace names for which this transformation will be applied.</span>
    <span class="c1">#</span>
    <span class="c1"># For example, to vectorize all function of the namespace MathFunctions, apply these options:</span>
    <span class="c1">#     options.fn_namespace_vectorize__regex: str = r&quot;MathFunctions^$&quot;</span>
    <span class="c1">#     options.fn_vectorize__regex = r&quot;.*&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># * fn_vectorize_prefix and fn_vectorize_suffix will be added to the vectorized functions names</span>
    <span class="c1">#   (they can be empty, in which case the vectorized function will be a usable overload with the same name)</span>
    <span class="n">fn_vectorize__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span>
    <span class="n">fn_namespace_vectorize__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span>
    <span class="n">fn_vectorize_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">fn_vectorize_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Return policy</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Force the function that match those regexes to use `pybind11::return_value_policy::reference`</span>
    <span class="c1">#</span>
    <span class="c1"># Note:</span>
    <span class="c1">#    you can also write &quot;// py::return_value_policy::reference&quot; as an end of line comment after the function.</span>
    <span class="c1">#    See packages/litgen/integration_tests/mylib/include/mylib/return_value_policy_test.h as an example</span>
    <span class="n">fn_return_force_policy_reference_for_pointers__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">fn_return_force_policy_reference_for_references__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Force overload</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Force using py::overload for functions that matches these regexes</span>
    <span class="n">fn_force_overload__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Force using a lambda for functions that matches these regexes</span>
    <span class="c1"># (useful when pybind11 is confused and gives error like</span>
    <span class="c1">#     error: no matching function for call to object of type &#39;const detail::overload_cast_impl&lt;...&gt;&#39;</span>
    <span class="n">fn_force_lambda__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># C style buffers to py::array</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1">#</span>
    <span class="c1"># Signatures with a C buffer like this:</span>
    <span class="c1">#       MY_API inline void add_inside_array(uint8_t* array, size_t array_size, uint8_t number_to_add)</span>
    <span class="c1"># may be transformed to:</span>
    <span class="c1">#       void add_inside_array(py::array &amp; array, uint8_t number_to_add)              (c++ bound signature)</span>
    <span class="c1">#       def add_inside_array(array: numpy.ndarray, number_to_add: int) -&gt; None       (python)</span>
    <span class="c1">#</span>
    <span class="c1"># It also works for templated buffers:</span>
    <span class="c1">#       MY_API template&lt;typename T&gt; void mul_inside_array(T* array, size_t array_size, double factor)</span>
    <span class="c1"># will be transformed to:</span>
    <span class="c1">#       void mul_inside_array(py::array &amp; array, double factor)                      (c++ bound signature)</span>
    <span class="c1">#       def mul_inside_array(array: numpy.ndarray, factor: float) -&gt; None            (python)</span>
    <span class="c1"># (and factor will be down-casted to the target type)</span>
    <span class="c1">#</span>
    <span class="c1"># fn_params_buffer_replace_by_array_regexes contains a regex on functions names</span>
    <span class="c1"># for which this transformation will be applied.</span>
    <span class="c1"># Set it to r&quot;.*&quot; to apply this to all functions, set it to &quot;&quot; to disable it</span>
    <span class="c1">#</span>
    <span class="n">fn_params_replace_buffer_by_array__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span>

    <span class="c1"># fn_params_buffer_types: list of numeric types that are considered as possible buffers.</span>
    <span class="c1"># You can customize this list in your own options by removing items from it,</span>
    <span class="c1"># but you *cannot* add new types or new synonyms (typedef for examples); since the conversion between</span>
    <span class="c1"># py::array and native relies on these *exact* names!</span>
    <span class="c1">#</span>
    <span class="c1"># By default, fn_params_buffer_types will contain those types:</span>
    <span class="n">fn_params_buffer_types</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">join_string_by_pipe_char</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;uint8_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int8_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint16_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int16_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint32_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;np_uint_l&quot;</span><span class="p">,</span>  <span class="c1"># Platform dependent: &quot;uint64_t&quot; on *nixes, &quot;uint32_t&quot; on windows</span>
            <span class="s2">&quot;np_int_l&quot;</span><span class="p">,</span>  <span class="c1"># Platform dependent: &quot;int64_t&quot; on *nixes, &quot;int32_t&quot; on windows</span>
            <span class="s2">&quot;float&quot;</span><span class="p">,</span>
            <span class="s2">&quot;double&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long double&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long long&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># fn_params_buffer_template_types: list of templated names that are considered as possible templated buffers</span>
    <span class="c1"># By default, only template&lt;typename T&gt; or template&lt;typename NumericType&gt; are accepted</span>
    <span class="n">fn_params_buffer_template_types</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">join_string_by_pipe_char</span><span class="p">([</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;NumericType&quot;</span><span class="p">])</span>

    <span class="c1"># fn_params_buffer_size_names__regex: possible names for the size of the buffer</span>
    <span class="c1"># = [&quot;nb&quot;, &quot;size&quot;, &quot;count&quot;, &quot;total&quot;, &quot;n&quot;] by default</span>
    <span class="n">fn_params_buffer_size_names__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">join_string_by_pipe_char</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">code_utils</span><span class="o">.</span><span class="n">make_regex_var_name_contains_word</span><span class="p">(</span><span class="s2">&quot;nb&quot;</span><span class="p">),</span>
            <span class="n">code_utils</span><span class="o">.</span><span class="n">make_regex_var_name_contains_word</span><span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">),</span>
            <span class="n">code_utils</span><span class="o">.</span><span class="n">make_regex_var_name_contains_word</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">),</span>
            <span class="n">code_utils</span><span class="o">.</span><span class="n">make_regex_var_name_contains_word</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">),</span>
            <span class="n">code_utils</span><span class="o">.</span><span class="n">make_regex_var_name_contains_word</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># C style arrays functions and methods parameters</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1">#</span>
    <span class="c1"># Signatures like</span>
    <span class="c1">#       void foo_const(const int input[2])</span>
    <span class="c1"># may be transformed to:</span>
    <span class="c1">#       void foo_const(const std::array&lt;int, 2&gt;&amp; input)    (c++ bound signature)</span>
    <span class="c1">#       def foo_const(input: List[int]) -&gt; None:           (python)</span>
    <span class="c1"># fn_params_replace_c_array_const_by_std_array__regex contains a list of regexes on functions names</span>
    <span class="c1"># for which this transformation will be applied.</span>
    <span class="c1"># Set it to r&quot;.*&quot; to apply this to all functions, set it to &quot;&quot; to disable it</span>
    <span class="n">fn_params_replace_c_array_const_by_std_array__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.*&quot;</span>

    <span class="c1"># Signatures like</span>
    <span class="c1">#       void foo_non_const(int output[2])</span>
    <span class="c1"># may be transformed to:</span>
    <span class="c1">#       void foo_non_const(BoxedInt &amp; output_0, BoxedInt &amp; output_1)         (c++ bound signature)</span>
    <span class="c1">#       def foo_non_const(output_0: BoxedInt, output_0: BoxedInt) -&gt; None    (python)</span>
    <span class="c1"># fn_params_replace_c_array_modifiable_by_boxed__regex contains a list of regexes on functions names</span>
    <span class="c1"># for which this transformation will be applied.</span>
    <span class="c1"># Set it to r&quot;.*&quot; to apply this to all functions, set it to &quot;&quot; to disable it</span>
    <span class="n">fn_params_replace_c_array_modifiable_by_boxed__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.*&quot;</span>
    <span class="c1"># (c_array_modifiable_max_size is the maximum number of params that can be boxed like this)</span>
    <span class="n">fn_params_replace_modifiable_c_array__max_size</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># C style string list functions and methods parameters</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Signatures like</span>
    <span class="c1">#     void foo(const char * const items[], int items_count)</span>
    <span class="c1"># may be transformed to:</span>
    <span class="c1">#     void foo(const std::vector&lt;std::string&gt;&amp; const items[])        (c++ bound signature)</span>
    <span class="c1">#     def foo(items: List[str]) -&gt; None                              (python)</span>
    <span class="c1"># fn_params_replace_c_string_list_regexes contains a list of regexes on functions names</span>
    <span class="c1"># for which this transformation will be applied.</span>
    <span class="c1"># Set it to [r&quot;.*&quot;] to apply this to all functions, set it to [] to disable it</span>
    <span class="n">fn_params_replace_c_string_list__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.*&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Make &quot;immutable python types&quot; modifiable, when passed by pointer or reference</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1">#</span>
    <span class="c1"># adapt functions params that use non const pointers or reference to a type that is immutable in python.</span>

    <span class="c1"># Signatures like</span>
    <span class="c1">#     int foo(int* value)</span>
    <span class="c1"># May be transformed to:</span>
    <span class="c1">#     def foo(BoxedInt value) -&gt; int                                  (python)</span>
    <span class="c1"># So that any modification done on the C++ side can be seen from python.</span>
    <span class="c1">#</span>
    <span class="c1"># fn_params_adapt_modifiable_immutable_regexes contains a list of regexes on functions names</span>
    <span class="c1"># Set it to r&quot;.*&quot; to apply this to all functions. Set it to &quot;&quot; to disable it</span>
    <span class="n">fn_params_replace_modifiable_immutable_by_boxed__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Make &quot;mutable default parameters&quot; behave like C++ default arguments</span>
    <span class="c1"># (i.e. re-evaluate the default value each time the function is called)</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Regex which contains a list of regexes on functions names for which this transformation will be applied.</span>
    <span class="c1"># by default, this is disabled (set it to r&quot;.*&quot; to enable it for all functions)</span>
    <span class="n">fn_params_adapt_mutable_param_with_default_value__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span>
    <span class="c1"># if True, auto-generated named constructors will adapt mutable default parameters</span>
    <span class="n">fn_params_adapt_mutable_param_with_default_value__to_autogenerated_named_ctor</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># if True, a comment will be added in the stub file to explain the behavior</span>
    <span class="n">fn_params_adapt_mutable_param_with_default_value__add_comment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># fn_params_adapt_mutable_param_with_default_value__fn_is_known_immutable_type</span>
    <span class="c1"># may contain a user defined function that will determine if a type is considered immutable in python based on its name.</span>
    <span class="c1"># By default, all the types below are considered immutable in python:</span>
    <span class="c1">#     &quot;int|float|double|bool|char|unsigned char|std::string|...&quot;</span>
    <span class="n">fn_params_adapt_mutable_param_with_default_value__fn_is_known_immutable_type</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Same as above, but for values</span>
    <span class="n">fn_params_adapt_mutable_param_with_default_value__fn_is_known_immutable_value</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Convert `const char* x = NULL` for Python passing None without TypeError</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Signatures like</span>
    <span class="c1">#     void foo(const char* text = NULL)</span>
    <span class="c1"># may be transformed to:</span>
    <span class="c1">#     void foo(std::optional&lt;std::string&gt; text = std::nullopt)</span>
    <span class="c1"># with a lambda function wrapping around original interface.</span>
    <span class="c1">#</span>
    <span class="c1"># NOTE: Enable this for nanobind.</span>
    <span class="n">fn_params_const_char_pointer_with_default_null</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># As an alternative, we can also add the modified value to the returned type</span>
    <span class="c1"># of the function (which will now be a tuple)</span>
    <span class="c1">#</span>
    <span class="c1"># For example</span>
    <span class="c1">#     int foo(int* value)</span>
    <span class="c1"># May be transformed to:</span>
    <span class="c1">#     def foo(int value) -&gt; Tuple[int, bool]</span>
    <span class="c1"># So that any modification done on the C++ side can be seen from python.</span>
    <span class="c1">#</span>
    <span class="c1"># fn_params_output_modifiable_immutable_to_return__regex contains a list of regexes on functions names</span>
    <span class="c1"># Set it to r&quot;.*&quot; to apply this to all functions. Set it to &quot;&quot; to disable it</span>
    <span class="n">fn_params_output_modifiable_immutable_to_return__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Custom adapters (advanced, very advanced and not documented here)</span>
    <span class="c1"># fn_custom_adapters may contain callables of signature</span>
    <span class="c1">#   f(adapted_function: AdaptedFunction) -&gt; Optional[LambdaAdapter]</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="n">fn_custom_adapters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;class, struct, and member adaptations&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># Exclude certain classes and structs by a regex on their name</span>
    <span class="n">class_exclude_by_name__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Exclude certain members by a regex on their name</span>
    <span class="n">member_exclude_by_name__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Exclude members based on their type</span>
    <span class="n">member_exclude_by_type__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Exclude certain members by a regex on their name, if class or struct name matched</span>
    <span class="c1"># For example:</span>
    <span class="c1">#   options.member_exclude_by_name_and_class__regex = {</span>
    <span class="c1">#       &quot;ImVector&quot;: join_string_by_pipe_char([</span>
    <span class="c1">#           r&quot;^Size$&quot;,</span>
    <span class="c1">#           r&quot;^Capacity$&quot;,</span>
    <span class="c1">#           ...</span>
    <span class="c1">#       ])</span>
    <span class="c1">#   }</span>
    <span class="n">member_exclude_by_name_and_class__regex</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>

    <span class="c1"># Make certain members read-only by a regex on their name</span>
    <span class="n">member_readonly_by_name__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Make certain members read-only based on their type</span>
    <span class="n">member_readonly_by_type__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># class_create_default_named_ctor__regex / struct_create_default_named_ctor__regex:</span>
    <span class="c1"># regex giving the list of class &amp; struct names for which we want to generate a named</span>
    <span class="c1"># constructor for Python, when no default constructor is provided by C++</span>
    <span class="c1"># (by default, this is active for all structs and not for the classes,</span>
    <span class="c1">#  in order for it to work, all struct members need to be default constructible if</span>
    <span class="c1">#  they are not declared with a default value)</span>
    <span class="n">struct_create_default_named_ctor__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.*&quot;</span>
    <span class="n">class_create_default_named_ctor__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span>

    <span class="c1"># class_expose_protected_methods__regex:</span>
    <span class="c1"># regex giving the list of class names for which we want to expose protected methods.</span>
    <span class="c1"># (by default, only public methods are exposed)</span>
    <span class="c1"># If active, this will use the technique described at</span>
    <span class="c1"># https://pybind11.readthedocs.io/en/stable/advanced/classes.html#binding-protected-member-functions)</span>
    <span class="n">class_expose_protected_methods__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># class_expose_protected_methods__regex:</span>
    <span class="c1"># regex giving the list of class names for which we want to be able to override virtual methods</span>
    <span class="c1"># from python.</span>
    <span class="c1"># (by default, this is not possible)</span>
    <span class="c1"># If active, this will use the technique described at</span>
    <span class="c1"># https://pybind11.readthedocs.io/en/stable/advanced/classes.html#overriding-virtual-functions-in-python</span>
    <span class="c1">#</span>
    <span class="c1"># Note: if you want to override protected functions, also fill `class_expose_protected_methods__regex`</span>
    <span class="n">class_override_virtual_methods_in_python__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># class_dynamic_attributes__regex</span>
    <span class="c1"># By default, classes exported from C++ do not support dynamic attributes and the only writable attributes are</span>
    <span class="c1"># the ones explicitly defined using class_::def_readwrite() or class_::def_property().</span>
    <span class="c1"># If active, this will use the technique described at</span>
    <span class="c1"># https://pybind11.readthedocs.io/en/stable/classes.html#dynamic-attributes</span>
    <span class="n">class_dynamic_attributes__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># class_deep_copy__regex &amp; class_copy__regex:</span>
    <span class="c1"># By default, structs and classes exported from C++ do not support (deep)copy.</span>
    <span class="c1"># However, if they do have a copy constructor (implicit or user defined),</span>
    <span class="c1"># (deep)copy can be enabled by invoking this constructor.</span>
    <span class="c1"># https://pybind11.readthedocs.io/en/stable/advanced/classes.html#deepcopy-support</span>
    <span class="n">class_deep_copy__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">class_copy__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># If class_copy_add_info_in_stub=True, the existence of __copy__ and __deepcopy__</span>
    <span class="c1"># will be mentioned in the stub file.</span>
    <span class="n">class_copy_add_info_in_stub</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># iterable classes: if some cpp classes expose begin()/end()/size(), they can be made iterable in python</span>
    <span class="c1"># Make classes iterables by setting:</span>
    <span class="c1">#     options.class_iterables_infos.add_iterable_class(python_class_name__regex, iterable_python_type_name)</span>
    <span class="n">class_iterables_infos</span><span class="p">:</span> <span class="n">ClassIterablesInfos</span>

    <span class="c1"># class_held_as_shared__regex:</span>
    <span class="c1"># Regex specifying the list of class names that should be held using std::shared_ptr in the generated bindings</span>
    <span class="c1"># (when using pybind11. This is unused for nanobind)</span>
    <span class="c1">#</span>
    <span class="c1"># **Purpose:**</span>
    <span class="c1"># By default, pybind11 uses `std::unique_ptr` as the holder type for bound classes.</span>
    <span class="c1">#</span>
    <span class="c1"># **When to Use:**</span>
    <span class="c1"># If your C++ code uses `std::shared_ptr` to manage instances of a class (e.g., as member variables, return types,</span>
    <span class="c1"># or parameters), and you expose that class to Python, you need to ensure that pybind11 uses `std::shared_ptr` as</span>
    <span class="c1"># the holder type for that class.</span>
    <span class="c1">#</span>
    <span class="c1"># **References:**</span>
    <span class="c1"># - [pybind11 Documentation: Smart Pointers](https://pybind11.readthedocs.io/en/stable/advanced/smart_ptrs.html)</span>
    <span class="c1"># - [Understanding Holder Types in pybind11](https://pybind11.readthedocs.io/en/stable/advanced/classes.html#custom-smart-pointers)</span>
    <span class="n">class_held_as_shared__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Templated class options</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Template class must be instantiated for the desired types, and a new name must be given for each instantiation</span>
    <span class="c1"># See https://pybind11.readthedocs.io/en/stable/advanced/classes.html#binding-classes-with-template-parameters</span>
    <span class="c1">#</span>
    <span class="c1"># class_template_options enables to set this</span>
    <span class="c1">#</span>
    <span class="c1"># For example</span>
    <span class="c1"># 1. this call would instantiate some classes for types &quot;int&quot; and &quot;const char *&quot;, with a naming scheme:</span>
    <span class="c1">#   MyClass&lt;int&gt; (cpp)  -&gt; MyClassInt (python)</span>
    <span class="c1">#   ------------------------------------------</span>
    <span class="c1">#     options.class_template_options.add_specialization(</span>
    <span class="c1">#         class_name_regex=r&quot;^MyPrefix&quot;,                 # r&quot;^MyPrefix&quot; =&gt; select class names with this prefix</span>
    <span class="c1">#         cpp_types_list=[&quot;int&quot;, &quot;const char *&quot;],        # instantiated types</span>
    <span class="c1">#         naming_scheme=TemplateNamingScheme.camel_case_suffix</span>
    <span class="c1">#     )</span>
    <span class="c1"># 2. this call would ignore all template classes:</span>
    <span class="c1">#        options.class_template_options.add_ignore(r&quot;.*&quot;)</span>
    <span class="c1">#    would ignore all template functions (they will not be exported)</span>
    <span class="n">class_template_options</span><span class="p">:</span> <span class="n">TemplateClassOptions</span>
    <span class="c1"># if class_template_decorate_in_stub is True, then there will be some</span>
    <span class="c1"># decorative comments in the stub file, in order to visually group</span>
    <span class="c1"># the generated classes together</span>
    <span class="n">class_template_decorate_in_stub</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># Adapt class members</span>
    <span class="c1"># ------------------------------------------------------------------------------</span>
    <span class="c1"># adapt class members which are a fixed size array of a numeric type:</span>
    <span class="c1">#</span>
    <span class="c1"># For example</span>
    <span class="c1">#       struct Foo {  int values[10]; };</span>
    <span class="c1"># May be transformed to:</span>
    <span class="c1">#       class Foo:</span>
    <span class="c1">#           values: numpy.ndarray</span>
    <span class="c1">#</span>
    <span class="c1"># i.e. the member will be transformed to a property that points to a numpy array</span>
    <span class="c1"># which can be read/written from python (this requires numpy)</span>
    <span class="c1"># This is active by default.</span>
    <span class="n">member_numeric_c_array_replace__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.*&quot;</span>

    <span class="c1"># member_numeric_c_array_types: list of numeric types that can be stored in a numpy array</span>
    <span class="c1"># for a class member which is a fixed size array of a numeric type</span>
    <span class="c1"># - Synonyms (defined via. `typedef` or `using`) are allowed here</span>
    <span class="c1"># - *don&#39;t* include char, *don&#39;t* include byte, those are not numeric!</span>
    <span class="c1">#   See https://numpy.org/doc/stable/reference/generated/numpy.chararray.html</span>
    <span class="n">member_numeric_c_array_types</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">join_string_by_pipe_char</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;int&quot;</span><span class="p">,</span>
            <span class="s2">&quot;unsigned int&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long&quot;</span><span class="p">,</span>
            <span class="s2">&quot;unsigned long&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long long&quot;</span><span class="p">,</span>
            <span class="s2">&quot;unsigned long long&quot;</span><span class="p">,</span>
            <span class="s2">&quot;float&quot;</span><span class="p">,</span>
            <span class="s2">&quot;double&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long double&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint8_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int8_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint16_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int16_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint32_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint64_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;namespace adaptations&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># All C++ namespaces in this list will not be emitted as a submodule</span>
    <span class="c1"># (i.e. their inner code will be placed in the root python module, or in the parent</span>
    <span class="c1"># module)</span>
    <span class="n">namespaces_root</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="c1"># All C++ namespaces that match this regex will be excluded</span>
    <span class="c1"># By default, any namespace whose name contains &quot;internal&quot; or &quot;detail&quot; will be excluded.</span>
    <span class="n">namespace_exclude__regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[Ii]nternal|[Dd]etail&quot;</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;enum adaptations&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1"># Exclude certain enums by a regex on their name</span>
    <span class="n">enum_exclude_by_name__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Remove the typical &quot;EnumName_&quot; prefix from &quot;C enum&quot; values.</span>
    <span class="c1"># For example, with the C enum:</span>
    <span class="c1">#     enum MyEnum { MyEnum_A = 0, MyEnum_B };</span>
    <span class="c1"># Values would be named &quot;a&quot; and &quot;b&quot; in python</span>
    <span class="n">enum_flag_remove_values_prefix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># A specific case for ImGui, which defines private enums which may extend the public ones:</span>
    <span class="c1">#     enum ImGuiMyFlags_ { ImGuiMyFlags_None = 0,...};  enum ImGuiMyFlagsPrivate_ { ImGuiMyFlags_PrivValue = ...};</span>
    <span class="n">enum_flag_remove_values_prefix_group_private</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Skip count value from enums, for example like in:</span>
    <span class="c1">#    enum MyEnum { MyEnum_A = 1, MyEnum_B = 1, MyEnum_COUNT };</span>
    <span class="n">enum_flag_skip_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># By default, all enums export rudimentary arithmetic and bit-level operations ( r&quot;.*&quot; matches any enum name)</span>
    <span class="n">enum_make_arithmetic__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.*&quot;</span>
    <span class="c1"># Export all entries of the enumeration into the parent scope.</span>
    <span class="n">enum_export_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;define adaptations&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1"># Simple preprocessor defines can be exported as global variables, e.g.:</span>
    <span class="c1">#     #define MY_VALUE 1</span>
    <span class="c1">#     #define MY_FLOAT 1.5</span>
    <span class="c1">#     #define MY_STRING &quot;abc&quot;</span>
    <span class="c1">#     #define MY_HEX_VALUE 0x00010009</span>
    <span class="c1"># This is limited to *simple* defines (no param, string, int, float or hex only)</span>
    <span class="c1"># By default nothing is exported</span>
    <span class="n">macro_define_include_by_name__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;globals vars adaptations&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1"># Global variable defines can be exported as global variables, e.g.:</span>
    <span class="c1"># By default nothing is exported (still experimental)</span>
    <span class="n">globals_vars_include_by_name__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;post processing&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="c1"># If you need to process the code after generation, fill these functions</span>
    <span class="n">postprocess_stub_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># run at the very end</span>
    <span class="n">postprocess_pydef_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Sanity checks and utilities below&gt;</span>
    <span class="c1">################################################################################</span>
    <span class="k">def</span> <span class="nf">check_options_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># the only authorized type are those for which the size is known with certainty</span>
        <span class="c1"># * int and long are not acceptable candidates: use int8_t, uint_8t, int32_t, etc.</span>
        <span class="c1"># * concerning float and doubles, there is no standard for fixed size floats, so we have to cope with</span>
        <span class="c1">#   float, double and long double and their various platforms implementations...</span>
        <span class="n">authorized_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;byte&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint8_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int8_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint16_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int16_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uint32_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;np_uint_l&quot;</span><span class="p">,</span>  <span class="c1"># Platform dependent: &quot;uint64_t&quot; on *nixes, &quot;uint32_t&quot; on windows</span>
            <span class="s2">&quot;np_int_l&quot;</span><span class="p">,</span>  <span class="c1"># Platform dependent: &quot;int64_t&quot; on *nixes, &quot;int32_t&quot; on windows</span>
            <span class="s2">&quot;float&quot;</span><span class="p">,</span>
            <span class="s2">&quot;double&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long double&quot;</span><span class="p">,</span>
            <span class="s2">&quot;long long&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">buffer_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fn_params_buffer_types_list</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">buffer_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">authorized_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    options.build_types contains an unauthorized type: </span><span class="si">{</span><span class="n">buffer_type</span><span class="si">}</span>
<span class="s2">                    Authorized types are: </span><span class="si">{</span><span class="w"> </span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">authorized_types</span><span class="p">)</span><span class="w"> </span><span class="si">}</span>
<span class="s2">                    &quot;&quot;&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_indent_cpp_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">space</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpp_indent_with_tabs</span> <span class="k">else</span> <span class="s2">&quot; &quot;</span>
        <span class="k">return</span> <span class="n">space</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpp_indent_size</span>

    <span class="k">def</span> <span class="nf">_indent_python_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">space</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">python_ident_with_tabs</span> <span class="k">else</span> <span class="s2">&quot; &quot;</span>
        <span class="k">return</span> <span class="n">space</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">python_indent_size</span>

    <span class="k">def</span> <span class="nf">_fn_params_buffer_types_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">split_string_by_pipe_char</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn_params_buffer_types</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fn_params_buffer_template_types_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">split_string_by_pipe_char</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn_params_buffer_template_types</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_member_numeric_c_array_types_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">split_string_by_pipe_char</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">member_numeric_c_array_types</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># See doc for all the params at their declaration site (scroll up to the top of this file!)</span>
        <span class="kn">from</span> <span class="nn">litgen.internal</span> <span class="kn">import</span> <span class="n">cpp_to_python</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">srcmlcpp_options</span> <span class="o">=</span> <span class="n">SrcmlcppOptions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">srcmlcpp_options</span><span class="o">.</span><span class="n">header_filter_preprocessor_regions</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type_replacements</span> <span class="o">=</span> <span class="n">cpp_to_python</span><span class="o">.</span><span class="n">standard_type_replacements</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_replacements</span> <span class="o">=</span> <span class="n">cpp_to_python</span><span class="o">.</span><span class="n">standard_value_replacements</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comments_replacements</span> <span class="o">=</span> <span class="n">cpp_to_python</span><span class="o">.</span><span class="n">standard_comment_replacements</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">function_names_replacements</span> <span class="o">=</span> <span class="n">RegexReplacementList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_names_replacements</span> <span class="o">=</span> <span class="n">RegexReplacementList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">macro_name_replacements</span> <span class="o">=</span> <span class="n">RegexReplacementList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace_names_replacements</span> <span class="o">=</span> <span class="n">RegexReplacementList</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fn_template_options</span> <span class="o">=</span> <span class="n">TemplateFunctionsOptions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_template_options</span> <span class="o">=</span> <span class="n">TemplateClassOptions</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">class_iterables_infos</span> <span class="o">=</span> <span class="n">ClassIterablesInfos</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fn_custom_adapters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespaces_root</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fn_exclude_by_name_and_signature</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">member_exclude_by_name_and_class__regex</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>

    </div>
    
    <script>
    var button = document.getElementById("btn_1731710856063_79_0");
    button.addEventListener("click", function() {
        this.classList.toggle("collapsible_header_opened");
        var content = document.getElementById("content_1731710856063_79_0");
        if (content.style.maxHeight){
          content.style.maxHeight = null;
        } else {
          content.style.maxHeight = collapsible_content.scrollHeight + "px";
        }
    });
    </script>
    
            <script>
            var collapsible_header = document.getElementById("btn_1731710856063_79_0");
            collapsible_header.classList.toggle("collapsible_header_opened");
            var collapsible_content = document.getElementById("content_1731710856063_79_0");
            collapsible_content.style.maxHeight = collapsible_content.scrollHeight + "px";
            </script>
            </div></div>
</div>
</section>
<section id="srcmlcpp-options">
<h2>srcmlcpp options<a class="headerlink" href="#srcmlcpp-options" title="Permalink to this heading">#</a></h2>
<p>litgen is based on srcmlcpp, which also provides some options, via <code class="docutils literal notranslate"><span class="pre">LitgenOptions.srcmlcpp_options</span></code>. They are available at <a class="reference external" href="https://github.com/pthom/litgen/blob/main/src/srcmlcpp/srcmlcpp_options.py">srcmlcpp/srcmlcpp_options.py</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">litgen_options_code</span> <span class="o">=</span> <span class="n">code_utils</span><span class="o">.</span><span class="n">download_url_content</span><span class="p">(</span>
    <span class="s2">&quot;https://raw.githubusercontent.com/pthom/litgen/main/src/srcmlcpp/srcmlcpp_options.py&quot;</span>
<span class="p">)</span>
<span class="n">litgen_demo</span><span class="o">.</span><span class="n">show_python_code</span><span class="p">(</span><span class="n">litgen_options_code</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;srcmlcpp/srcmlcpp_options.py&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<style>
.collapsible_header {
  background-color: #AAAAAA;
  color: white;
  cursor: pointer;
  padding: 3px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-style: italic;
}

.collapsible_header_opened {
  background-color: #555;
}

.collapsible_header:hover {
  background-color: #AAAAFF;
}

.collapsible_header:after {
  content: '\002B';
  color: white;
  font-weight: bold;
  float: right;
  margin-left: 5px;
}

.collapsible_header_opened:after {
  content: "\2212";
}

.collapsible_content {
  padding: 0 18px;
  max-height: 0;
  overflow-x: scroll;
  overflow-y: scroll;
  min-width: 100%;
  transition: max-height 0.2s ease-out;
  background-color: #f1f1f1;
}
</style>

    <script>
       function copy_code_1731710856298_79() {
            let code = `"""
Options for srcmlcpp. Read the doc near all options elements.
"""
from __future__ import annotations
from typing import Callable, Optional

from codemanip.code_utils import split_string_by_pipe_char
from srcmlcpp.scrml_warning_settings import WarningType


class SrcmlcppOptions:
    ################################################################################
    #    <API prefixes for functions / API comment suffixes for classes>
    ################################################################################

    # Prefixes that denote exported dll functions.
    # For example, you could use "MY_API" which would be defined as \`__declspec(dllexport|dllimport)\` on windows
    # You can have several prefixes: separate them with a "|", for example: "MY_API|OTHER_API"
    #
    # If you filled SrcmlcppOptions.functions_api_prefixes, then those prefixes will be mentioned
    # as specifiers for the return type of the functions.
    functions_api_prefixes: str = ""

    ################################################################################
    #    <Numbers parsing: resolve macros values>
    ################################################################################

    # List of named possible numbers or sizes (fill it if some number/sizes are defined by macros or constexpr values)
    # For example it could store \`{ "SPACE_DIMENSIONS" : 3 }\` if the C++ code uses a macro \`SPACE_DIMENSIONS\`
    named_number_macros: dict[str, int]

    ################################################################################
    #    <Exclude certain regions based on preprocessor macros>
    ################################################################################

    # Set header_filter_preprocessor_regions to True if the header has regions
    # that you want to exclude from the parsing, like this:
    #       #ifdef SOME_RARE_OPTION
    #           // code we want to exclude
    #       #endif
    #
    # See srcmlcpp/filter_preprocessor_regions.py for more complete examples
    header_filter_preprocessor_regions: bool = False
    # If header_filter_preprocessor_regions is True,
    # you need to also fill header_filter_acceptable__regex in order to accept code contained
    # inside header_guards (and other acceptable preprocessor defines you may set via this regex)
    # Your regex can have several options: separate them with a "|".
    # By default, all macros names ending with "_H", "HPP", "HXX" are considered as acceptable.
    header_filter_acceptable__regex: str = "__cplusplus|_h_\$|_h\$|_H\$|_H_\$|hpp\$|HPP\$|hxx\$|HXX\$"

    ################################################################################
    #    <Custom preprocess of the code>
    ################################################################################

    #
    # If you need to preprocess the code before parsing, fill this function
    #
    code_preprocess_function: Optional[Callable[[str], str]] = None

    ################################################################################
    #    <Misc options>
    ################################################################################

    # Encoding of python and C++ files
    encoding: str = "utf-8"

    # Preserve empty lines, i.e. any empty line in the C++ code will be mentioned as a CppEmptyLine element
    # this is done by adding a dummy comment on the line.
    preserve_empty_lines: bool = True

    # flag_srcml_dump_positions: if True, code positions will be outputted in the xml tree (recommended)
    flag_srcml_dump_positions: bool = True

    # indentation used by CppElements str_code() methods (4 spaces by default)
    indent_cpp_str: str = "    "

    ################################################################################
    #    <Verbose / Quiet mode>
    ################################################################################

    # if quiet, all warning messages are discarded (warning messages go to stderr)
    flag_quiet: bool = False

    # List of ignored warnings
    ignored_warnings: list[WarningType]
    # List of ignored warnings, identified by a part of the warning message
    ignored_warning_parts: list[str]

    # Show python callstack when warnings are raised
    flag_show_python_callstack: bool = False

    # if true, display parsing progress during execution (on stdout)
    flag_show_progress: bool = False

    ################################################################################
    # Workaround for https://github.com/srcML/srcML/issues/1833
    ################################################################################
    fix_brace_init_default_value = True

    ################################################################################
    #    <End>
    ################################################################################

    def __init__(self) -> None:
        # See doc for all the params at their declaration site (scroll up!)
        self.named_number_macros = {}
        self.ignored_warnings = []
        self.ignored_warning_parts = []

    def functions_api_prefixes_list(self) -> list[str]:
        assert isinstance(self.functions_api_prefixes, str)
        return split_string_by_pipe_char(self.functions_api_prefixes)


def _int_from_str_or_named_number_macros(options: SrcmlcppOptions, int_str: Optional[str]) -> Optional[int]:
    if int_str is None:
        return None

    try:
        v = int(int_str)
        return v
    except ValueError:
        if int_str in options.named_number_macros:
            return options.named_number_macros[int_str]
        else:
            return None
`;
            navigator.clipboard.writeText(code);
       }
    </script>
    <button class="collapsible_header" id="btn_1731710856298_79_1" >srcmlcpp/srcmlcpp_options.py</button>
    <div class="collapsible_content" id="content_1731710856298_79_1">
        <div>
                <button onclick="copy_code_1731710856298_79()" align="right">copy &#x270d;</button>
        </div>
        <style>pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #3c3836 }
.highlight { background: #fbf1c7; }
.highlight .c { color: #928374; font-style: italic } /* Comment */
.highlight .err { color: #fbf1c7; background-color: #9d0006 } /* Error */
.highlight .k { color: #9d0006 } /* Keyword */
.highlight .ch { color: #928374; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #928374; font-style: italic } /* Comment.Multiline */
.highlight .c-PreProc { color: #427b58; font-style: italic } /* Comment.PreProc */
.highlight .cp { color: #928374; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #928374; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #928374; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3c3836; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #fbf1c7; background-color: #9d0006 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #9d0006 } /* Generic.Error */
.highlight .gh { color: #3c3836; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #fbf1c7; background-color: #79740e } /* Generic.Inserted */
.highlight .go { color: #32302f } /* Generic.Output */
.highlight .gp { color: #7c6f64 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #3c3836; text-decoration: underline } /* Generic.Subheading */
.highlight .gt { color: #9d0006 } /* Generic.Traceback */
.highlight .kc { color: #9d0006 } /* Keyword.Constant */
.highlight .kd { color: #9d0006 } /* Keyword.Declaration */
.highlight .kn { color: #9d0006 } /* Keyword.Namespace */
.highlight .kp { color: #9d0006 } /* Keyword.Pseudo */
.highlight .kr { color: #9d0006 } /* Keyword.Reserved */
.highlight .kt { color: #9d0006 } /* Keyword.Type */
.highlight .m { color: #8f3f71 } /* Literal.Number */
.highlight .s { color: #79740e } /* Literal.String */
.highlight .na { color: #b57614 } /* Name.Attribute */
.highlight .nb { color: #af3a03 } /* Name.Builtin */
.highlight .nc { color: #427b58 } /* Name.Class */
.highlight .no { color: #8f3f71 } /* Name.Constant */
.highlight .nd { color: #9d0006 } /* Name.Decorator */
.highlight .ne { color: #9d0006 } /* Name.Exception */
.highlight .nf { color: #427b58 } /* Name.Function */
.highlight .nn { color: #427b58 } /* Name.Namespace */
.highlight .nt { color: #427b58 } /* Name.Tag */
.highlight .nv { color: #076678 } /* Name.Variable */
.highlight .ow { color: #9d0006 } /* Operator.Word */
.highlight .mb { color: #8f3f71 } /* Literal.Number.Bin */
.highlight .mf { color: #8f3f71 } /* Literal.Number.Float */
.highlight .mh { color: #8f3f71 } /* Literal.Number.Hex */
.highlight .mi { color: #8f3f71 } /* Literal.Number.Integer */
.highlight .mo { color: #8f3f71 } /* Literal.Number.Oct */
.highlight .sa { color: #79740e } /* Literal.String.Affix */
.highlight .sb { color: #79740e } /* Literal.String.Backtick */
.highlight .sc { color: #79740e } /* Literal.String.Char */
.highlight .dl { color: #79740e } /* Literal.String.Delimiter */
.highlight .sd { color: #79740e } /* Literal.String.Doc */
.highlight .s2 { color: #79740e } /* Literal.String.Double */
.highlight .se { color: #af3a03 } /* Literal.String.Escape */
.highlight .sh { color: #79740e } /* Literal.String.Heredoc */
.highlight .si { color: #79740e } /* Literal.String.Interpol */
.highlight .sx { color: #79740e } /* Literal.String.Other */
.highlight .sr { color: #79740e } /* Literal.String.Regex */
.highlight .s1 { color: #79740e } /* Literal.String.Single */
.highlight .ss { color: #79740e } /* Literal.String.Symbol */
.highlight .bp { color: #af3a03 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #427b58 } /* Name.Function.Magic */
.highlight .vc { color: #076678 } /* Name.Variable.Class */
.highlight .vg { color: #076678 } /* Name.Variable.Global */
.highlight .vi { color: #076678 } /* Name.Variable.Instance */
.highlight .vm { color: #076678 } /* Name.Variable.Magic */
.highlight .il { color: #8f3f71 } /* Literal.Number.Integer.Long */</style> <div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Options for srcmlcpp. Read the doc near all options elements.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="nn">codemanip.code_utils</span> <span class="kn">import</span> <span class="n">split_string_by_pipe_char</span>
<span class="kn">from</span> <span class="nn">srcmlcpp.scrml_warning_settings</span> <span class="kn">import</span> <span class="n">WarningType</span>


<span class="k">class</span> <span class="nc">SrcmlcppOptions</span><span class="p">:</span>
    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;API prefixes for functions / API comment suffixes for classes&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># Prefixes that denote exported dll functions.</span>
    <span class="c1"># For example, you could use &quot;MY_API&quot; which would be defined as `__declspec(dllexport|dllimport)` on windows</span>
    <span class="c1"># You can have several prefixes: separate them with a &quot;|&quot;, for example: &quot;MY_API|OTHER_API&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># If you filled SrcmlcppOptions.functions_api_prefixes, then those prefixes will be mentioned</span>
    <span class="c1"># as specifiers for the return type of the functions.</span>
    <span class="n">functions_api_prefixes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Numbers parsing: resolve macros values&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># List of named possible numbers or sizes (fill it if some number/sizes are defined by macros or constexpr values)</span>
    <span class="c1"># For example it could store `{ &quot;SPACE_DIMENSIONS&quot; : 3 }` if the C++ code uses a macro `SPACE_DIMENSIONS`</span>
    <span class="n">named_number_macros</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Exclude certain regions based on preprocessor macros&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># Set header_filter_preprocessor_regions to True if the header has regions</span>
    <span class="c1"># that you want to exclude from the parsing, like this:</span>
    <span class="c1">#       #ifdef SOME_RARE_OPTION</span>
    <span class="c1">#           // code we want to exclude</span>
    <span class="c1">#       #endif</span>
    <span class="c1">#</span>
    <span class="c1"># See srcmlcpp/filter_preprocessor_regions.py for more complete examples</span>
    <span class="n">header_filter_preprocessor_regions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># If header_filter_preprocessor_regions is True,</span>
    <span class="c1"># you need to also fill header_filter_acceptable__regex in order to accept code contained</span>
    <span class="c1"># inside header_guards (and other acceptable preprocessor defines you may set via this regex)</span>
    <span class="c1"># Your regex can have several options: separate them with a &quot;|&quot;.</span>
    <span class="c1"># By default, all macros names ending with &quot;_H&quot;, &quot;HPP&quot;, &quot;HXX&quot; are considered as acceptable.</span>
    <span class="n">header_filter_acceptable__regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;__cplusplus|_h_$|_h$|_H$|_H_$|hpp$|HPP$|hxx$|HXX$&quot;</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Custom preprocess of the code&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1">#</span>
    <span class="c1"># If you need to preprocess the code before parsing, fill this function</span>
    <span class="c1">#</span>
    <span class="n">code_preprocess_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Misc options&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># Encoding of python and C++ files</span>
    <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;utf-8&quot;</span>

    <span class="c1"># Preserve empty lines, i.e. any empty line in the C++ code will be mentioned as a CppEmptyLine element</span>
    <span class="c1"># this is done by adding a dummy comment on the line.</span>
    <span class="n">preserve_empty_lines</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># flag_srcml_dump_positions: if True, code positions will be outputted in the xml tree (recommended)</span>
    <span class="n">flag_srcml_dump_positions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># indentation used by CppElements str_code() methods (4 spaces by default)</span>
    <span class="n">indent_cpp_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;    &quot;</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;Verbose / Quiet mode&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="c1"># if quiet, all warning messages are discarded (warning messages go to stderr)</span>
    <span class="n">flag_quiet</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># List of ignored warnings</span>
    <span class="n">ignored_warnings</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">WarningType</span><span class="p">]</span>
    <span class="c1"># List of ignored warnings, identified by a part of the warning message</span>
    <span class="n">ignored_warning_parts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="c1"># Show python callstack when warnings are raised</span>
    <span class="n">flag_show_python_callstack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># if true, display parsing progress during execution (on stdout)</span>
    <span class="n">flag_show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">################################################################################</span>
    <span class="c1"># Workaround for https://github.com/srcML/srcML/issues/1833</span>
    <span class="c1">################################################################################</span>
    <span class="n">fix_brace_init_default_value</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">################################################################################</span>
    <span class="c1">#    &lt;End&gt;</span>
    <span class="c1">################################################################################</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># See doc for all the params at their declaration site (scroll up!)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_number_macros</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignored_warnings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignored_warning_parts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">functions_api_prefixes_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_api_prefixes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">split_string_by_pipe_char</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_api_prefixes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_int_from_str_or_named_number_macros</span><span class="p">(</span><span class="n">options</span><span class="p">:</span> <span class="n">SrcmlcppOptions</span><span class="p">,</span> <span class="n">int_str</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">int_str</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">int_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">int_str</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">named_number_macros</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">options</span><span class="o">.</span><span class="n">named_number_macros</span><span class="p">[</span><span class="n">int_str</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
</pre></div>

    </div>
    
    <script>
    var button = document.getElementById("btn_1731710856298_79_1");
    button.addEventListener("click", function() {
        this.classList.toggle("collapsible_header_opened");
        var content = document.getElementById("content_1731710856298_79_1");
        if (content.style.maxHeight){
          content.style.maxHeight = null;
        } else {
          content.style.maxHeight = collapsible_content.scrollHeight + "px";
        }
    });
    </script>
    
            <script>
            var collapsible_header = document.getElementById("btn_1731710856298_79_1");
            collapsible_header.classList.toggle("collapsible_header_opened");
            var collapsible_content = document.getElementById("content_1731710856298_79_1");
            collapsible_content.style.maxHeight = collapsible_content.scrollHeight + "px";
            </script>
            </div></div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="02_00_00_first_steps.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">First steps</p>
      </div>
    </a>
    <a class="right-next"
       href="02_05_00_headers.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Headers processing</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#note-about-regexes">Note about regexes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#litgen-main-options">litgen main options</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#srcmlcpp-options">srcmlcpp options</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pascal Thomet
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>